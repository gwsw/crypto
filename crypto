#!/usr/bin/perl
use strict;
use bignum;
use Getopt::Long;
use Time::HiRes qw(time);
use Digest::SHA;

Math::BigInt->accuracy(undef);
my $saved;

my $rng_bits_default    = 32;
my $mr_loops_default    = 8;
my $rabin_shift_default = 8;
my $rng; # the active RNG, returned from *_rng_init

my %rngs = (
    'std' => \&std_rng_init, 
    'sec' => \&sec_rng_init, 
    'bbs' => \&bbs_rng_init, 
);

my %opt; # currently set options

my %all_options = (
    'hex'         => [ 'b', "Print numbers in hex." ],
    'loops'       => [ 'i', "Number of loops in Miller-Rabin (default $mr_loops_default)." ],
    'orig-rsa'    => [ 'b', "Use phi rather than lambda in calculating decryption exponent." ],
    'rng'         => [ 's', "Random number generator (".join(',',keys %rngs)."). Optional bits follows colon (eg. \"bbs:64\").", \&opt_rng ],
    'seed'        => [ 's', "Seed string for RNG.", \&opt_seed ],
    'slow-eg'     => [ 'b', "Don't use Lagrange Theorem shortcut to compute mult. inverse." ],
    'rabin-shift' => [ 'i', "Bits to use for Rabin disambiguation (default $rabin_shift_default)." ],
    'rand-rsa'    => [ 'b', "Use random encrytion key rather than 65537." ],
    'raw-rabin'   => [ 'b', "Don't pad message; decryption prints all 4 candidates." ],
    'no-prompt'   => [ 'b', "Don't print prompts." ],
);
my %all_commands = (
    'euclid'          => [ \&cmd_euclid,          "NUM1 NUM2\n" ],
    'exp'             => [ \&cmd_exp,             "BASE EXP MOD\n" ],
    'find-prime'      => [ \&cmd_find_prime,      "BITS\n" ],
    'gcd'             => [ \&cmd_gcd,             "NUM1 NUM2\n" ],
    'help'            => [ \&cmd_help,            "[command]\n" ],
    'inv'             => [ \&cmd_inv,             "NUM MOD\n" ],
    'is-prime'        => [ \&cmd_is_prime,        "NUM\n" ],
    'kx'              => [ \&cmd_kx,              "BITS\n" ],
    'lcm'             => [ \&cmd_lcm,             "NUM1 NUM2\n" ],
    'luhn'            => [ \&cmd_luhn,            "[-g] CCN\n" ],
    'random'          => [ \&cmd_random,          "MIN MAX\n" ],
    'random-bytes'    => [ \&cmd_random_bytes,    "BYTES\n" ],
    'shuffle'         => [ \&cmd_shuffle,         "NUM\n" ],
    'verhoeff'        => [ \&cmd_verhoeff,        "[-g] CCN\n" ],
    'rsa-gen'         => [ \&cmd_rsa_gen,         "BITS\n" ],
    'rsa-encrypt'     => [ \&cmd_rsa_encrypt,     "{N E} MSG\n" ],
    'rsa-decrypt'     => [ \&cmd_rsa_decrypt,     "{N D} MSG\n" ],
    'eg-gen'          => [ \&cmd_eg_gen,          "BITS\n" ],
    'eg-sign'         => [ \&cmd_eg_sign,         "   {P G X} MSG\n" ],
    'eg-verify'       => [ \&cmd_eg_verify,       " {P G Y} R S MSG\n" ],
    'eg-encrypt'      => [ \&cmd_eg_encrypt,      "{P G Y} MSG\n" ],
    'eg-decrypt'      => [ \&cmd_eg_decrypt,      "{P G X} R S\n" ],
    'rabin-gen'       => [ \&cmd_rabin_gen,       "BITS\n" ],
    'rabin-encrypt'   => [ \&cmd_rabin_encrypt,   "{N} MSG\n" ],
    'rabin-decrypt'   => [ \&cmd_rabin_decrypt,   "{P Q N} MSG\n" ],
    'schnorr-gen'     => [ \&cmd_schnorr_gen,     "BITS QBITS\n" ],
    'schnorr-sign'    => [ \&cmd_schnorr_sign,    "{P Q A QBITS S} MSG\n" ],
    'schnorr-verify'  => [ \&cmd_schnorr_verify,  "{P Q A QBITS V} E Y MSG\n" ],
    'option'          => [ \&cmd_option,          "[+!]OPTION[=VALUE]...\n" ],
);
my %set_alias = ( 'on' => 1, 'off' => 0 );

# -----------------------------------------------------------------
sub usage(;$) {
    my ($acmd) = @_;
    my $cmd = $acmd;
    if ($cmd eq 'shell') {
        $cmd = '';
        print "usage: crypto [options] [command args...]\n";
        usage_options(1);
    }
    if (not $cmd) {
        print "commands: (values in {} may be '-' if preceded by *-gen)\n";
        foreach my $wcmd (sort keys %all_commands) {
            my $command = $all_commands{$wcmd};
            my ($handler, $args) = @$command;
            print "  $wcmd $args";
            usage_options(0) if $wcmd eq 'option' and $acmd ne 'shell';
        }
    } else {
        my $command = $all_commands{$cmd};
        if (not $command) {
            print "invalid command \"$cmd\"\n";
        } else {
            my ($handler, $args) = @$command;
            print "  $cmd $args";
            usage_options(0) if $cmd eq 'option';
        }
    }
    return 0;
}

# -----------------------------------------------------------------
sub usage_options {
    my ($dashes) = @_;
    my $dash = $dashes ? '--' : '';
    foreach my $var (sort keys %all_options) {
        my $option = $all_options{$var};
        my ($type, $desc) = @$option;
        printf "        $dash%-13s %s\n", $var . ($type eq 'b' ? ' ' : '='), $desc;
    }
}

# -----------------------------------------------------------------
exit (main() ? 0 : 1);
sub main {
    my @alist;
    while (my ($var,$option) = each %all_options) {
        my ($type) = @$option;
        $var .= "=$type" unless $type eq 'b';
        push @alist, $var;
    }
    return usage('shell') if not GetOptions(\%opt, @alist);
    $opt{loops} = $mr_loops_default if not $opt{loops};
    $opt{'rabin-shift'} = $rabin_shift_default if not $opt{'rabin-shift'};
    $opt{rng} = 'std' if not $opt{rng};
    $opt{seed} = time() if not $opt{seed};
    return usage() if not set_rng($opt{rng}, $opt{seed});

    # Change 'crypto help' to 'crypto help shell'.
    if (@ARGV == 1 and $ARGV[0] eq 'help') { push @ARGV, 'shell'; }

    return command(@ARGV) if @ARGV; # crypto command is on cmd line

    # Interactive mode.
    my $ok = 1;
    for (;;) {
        printf "> " unless $opt{'no-prompt'};
        my $line = <>;
        last if not defined $line;
        $line =~ s/^\s+//;
        $line =~ s/\s$//;
        next if $line eq '';
        next if $line =~ /^#/;
        last if $line eq 'q' or $line eq 'quit' or $line eq 'exit';
        my @args;
        my $quoting = 0;
        my $qarg = '';
        foreach my $arg (split /(\s+|")/, $line.' ') {
            if ($arg eq '"') {
                $quoting = not $quoting;
                $qarg .= $arg;
            } elsif ($quoting) {
                $qarg .= $arg;
            } elsif ($arg !~ /^\s*$/) {
                $qarg .= $arg;
            } elsif ($arg =~ /\s+/) {
                push @args, $qarg;
                $qarg = '';
            }
        }
        if (not command(@args)) {
            print "*** command failed\n";
            $ok = 0;
        }
    }
    return $ok;
}

# -----------------------------------------------------------------
sub set_rng($$) {
    my ($rname, $seed) = @_;
    my $bits = $rng_bits_default;
    if ($rname =~ /^([^:]+) : (\d+)/x) {
        ($rname, $bits) = ($1,$2);
    }
    my $init = $rngs{$rname};
    return undef if not $init;
    my $new_rng = &$init($bits, $seed);
    $rng = $new_rng if $new_rng;
    return $new_rng;
}

# -----------------------------------------------------------------
sub command(@) {
    my $cmd = $_[0];
    return if not $cmd;
    my $command = $all_commands{$cmd};
    if (not $command) {
        print "invalid command \"$cmd\"; use \"help\" for help\n";
        return 1;
    }
    my ($handler) = @$command;
    my $start_time = time();
    my $ret = &$handler(@_);
    printf "=%.6f sec\n", time()-$start_time if $opt{t} and $ret;
    return $ret;
}

# -----------------------------------------------------------------
sub cmd_help {
    my ($cmd, $help_cmd) = @_;
    usage($help_cmd);
    return 1;
}

# -----------------------------------------------------------------
sub cmd_euclid {
    my ($cmd, $u, $v) = args(\@_);
    return usage($cmd) if not defined $v;
    if ($u < $v) { ($u,$v) = ($v,$u); }
    my ($w,$x,$a,$b,$gcd,$k) = euclid($u, $v);
    my $ngcd = number($gcd);
    print $ngcd, ' = ', number($a), ' * ', number($w), ' - ', number($b), ' * ', number($x), "\n";
    print (' ' x length($ngcd));
    print ' = (', number($a), '>>', number($k), ') * ', number($u), ' - (', number($b), '>>', number($k), ') * ', number($v), "\n";
    if ($gcd == 1) {
        print number($x), '^-1 mod ', number($w), ' = ', number($w-$b), "\n";
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_exp {
    my ($cmd, $base, $exp, $mod) = args(\@_);
    return usage($cmd) if not $mod;
    my $n = pow_mod($base, $exp, $mod);
    print number($n), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_find_prime {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits;
    my $n = find_prime($bits);
    print number($n), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_is_prime {
    my ($cmd, $num) = args(\@_);
    return usage($cmd) if not $num;
    print is_prime($num) ? "probably prime\n" : "composite\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_gcd {
    my ($cmd, $u, $v) = args(\@_);
    return usage($cmd) if not defined $v;
    my $gcd = gcd($u, $v);
    print number($gcd), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_inv {
    my ($cmd, $num, $mod) = args(\@_);
    return usage($cmd) if not defined $mod;
    my $inv = inv($num, $mod);
    print number($inv), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_lcm {
    my ($cmd, $u, $v) = args(\@_);
    return usage($cmd) if not defined $v;
    my $lcm = lcm($u, $v);
    print number($lcm), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_random {
    my ($cmd, $min, $max) = args(\@_);
    return usage($cmd) if not $max;
    my $n = random($min, $max);
    print number($n), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_random_bytes {
    my ($cmd, $bytes) = args(\@_);
    return usage($cmd) if not $bytes;
    my $data = $rng->{get}($rng, $bytes);
    if (not $data) {
        print "RNG failed\n";
        return 0;
    }
    for (my $i = 0; $i < length $data; ++$i) {
        printf "%02x ", ord substr($data,$i,1);
    }
    print "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_shuffle {
    my ($cmd, $num) = args(\@_);
    return usage($cmd) if not $num;
    my @nums = 1 .. $num;
    shuffle(\@nums);
    print join(' ', @nums), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rsa_gen {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits or $bits < 3;
    my $rsa = rsa_gen($bits);
    if ($rsa) {
        save_obj($rsa);
        print_map($rsa, 'e','d','n');
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rsa_encrypt {
    my ($cmd, $n,$e,$msg) = args(\@_, 'n','e');
    return usage($cmd) if not $n or not $e or not defined $msg;
    my $num = rsa_crypt($msg, $e, $n);
    print number($num), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rsa_decrypt {
    my ($cmd, $n,$d,$msg) = args(\@_, 'n','d');
    return usage($cmd) if not $n or not $d or not defined $msg;
    my $num = rsa_crypt($msg, $d, $n);
    print number($num), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_gen {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits or $bits < 3;
    my $eg = eg_gen($bits);
    if ($eg) {
        save_obj($eg);
        print_map($eg, 'p','g','y','x');
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_sign {
    my ($cmd, $p,$g,$x,$msg) = args(\@_, 'p','g','x');
    return usage($cmd) if not $msg;
    my $sig = eg_sign($p,$g,$x,$msg);
    if ($sig) {
        print number($$sig{r}), ' ', number($$sig{s}), "\n";
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_verify {
    my ($cmd, $p,$g,$y,$r,$s,$msg) = args(\@_, 'p','g','y');
    return usage($cmd) if not $s;
    if (not eg_verify($p,$g,$y,$r,$s,$msg)) {
        print "FAIL\n";
        return 0;
    }
    print "ok\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_encrypt {
    my ($cmd, $p,$g,$y,$msg) = args(\@_, 'p','g','y');
    return usage($cmd) if not $msg;
    my $enc = eg_encrypt($p,$g,$y,$msg);
    if ($enc) {
        print number($$enc{r}), ' ', number($$enc{s}), "\n";
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_decrypt {
    my ($cmd, $p,$g,$x,$r,$s) = args(\@_, 'p','g','x');
    return usage($cmd) if not $s;
    my $msg = eg_decrypt($p,$g,$x,$r,$s);
    if ($msg) {
        print number($msg), "\n";
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rabin_gen {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits;
    $bits += $opt{'rabin-shift'} if not $opt{'raw-rabin'};
    my $rabin = rabin_gen($bits);
    if ($rabin) {
        save_obj($rabin);
        print_map($rabin, 'p','q','n');
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rabin_encrypt {
    my ($cmd, $n,$msg) = args(\@_, 'n');
    return usage($cmd) if not $n or not defined $msg;
    # Use N low order zero bits to distinguish between 4 posssible decryptions.
    $msg = lshift($msg, $opt{'rabin-shift'}) if not $opt{'raw-rabin'};
    my $enc = rabin_encrypt($msg, $n);
    if ($enc) {
        print number($enc), "\n";
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rabin_decrypt {
    my ($cmd, $p,$q,$n,$enc) = args(\@_, 'p','q','n');
    return usage($cmd) if not $p or not $q or not defined $enc;
    # Look for the correct decryption among the 4.
    my $decs = rabin_decrypt($enc, $p, $q, $n);
    if (not $decs) { 
        print "decrypt failed\n";
    } else {
        foreach my $m (@$decs) {
            if ($opt{'raw-rabin'}) { # just print them all.
                print number($m), "\n";
            } elsif (($m & rmask($opt{'rabin-shift'})) == 0) {
                # Found one with N low order zero bits.
                # It might be the right decryption (or we might be very unlucky).
                print number(rshift($m, $opt{'rabin-shift'})), "\n";
            }
        }
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_schnorr_gen {
    my ($cmd, $bits, $qbits) = args(\@_);
    return usage($cmd) if not $qbits or $qbits >= $bits;
    my $sch = schnorr_gen($bits, $qbits);
    if ($sch) {
        save_obj($sch);
        print_map($sch, 'p','q','a','qbits','s','v');
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_schnorr_sign {
    my ($cmd, $p,$q,$a,$qbits,$s,$msg) = args(\@_, 'p','q','a','qbits','s');
    return usage($cmd) if not $msg;
    my $sig = schnorr_sign($p,$q,$a,$qbits,$s,$msg);
    if ($sig) {
        print number($$sig{e}), ' ', number($$sig{y}), "\n";
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_schnorr_verify {
    my ($cmd, $p,$q,$a,$qbits,$v,$e,$y,$msg) = args(\@_, 'p','q','a','qbits','v');
    return usage($cmd) if not $msg;
    if (not schnorr_verify($p,$q,$a,$qbits,$v,$e,$y,$msg)) {
        print "FAIL\n";
        return 0;
    }
    print "ok\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_kx {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits;
    dh_key_exchange($bits);
    return 1;
}

# -----------------------------------------------------------------
sub cmd_ccn {
    my ($cmd, $flag, $ccn) = @_;
    my $gen = ($flag and $flag eq '-g');
    $ccn = $flag if not $gen;
    return usage($cmd) if not defined $ccn;
    my $ch = ($cmd eq 'luhn') ? luhn($ccn, $gen) : verhoeff($ccn, $gen);
    if (not defined $ch) {
        print "INVALID DIGIT\n";
        return 0;
    } elsif ($gen) {
        print "$ccn$ch\n";
    } elsif ($ch == 0) {
        print "ok\n";
    } else {
        print "INVALID CHECK\n";
        return 0;
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_option {
    my $cmd = shift @_;
    if (not @_) { # print all options
        foreach my $var (keys %all_options) {
            print_option($var);
        }
        return 1;
    }
    foreach my $var (@_) {
        # var may be 'name', '!name', '+name', 'name=value'.
        my $set = undef;
        if ($var =~ /([!+]) (.*)/x) { # !name or +name
            $var = $2;
            $set = ($1 eq '+') ? 1 : 0;
        }
        if ($var =~ /^ ([^=]+) = "([^"]*)" \s*$ /x) { # name="value"
            $var = $1;
            $set = $2;
        }
        if ($var =~ /^ ([^=]+) = (.*) \s*$ /x) { # name=value
            $var = $1;
            $set = $2;
        }
        if ($set_alias{lc($set)}) { $set = $set_alias{lc($set)}; }
        my $option = $all_options{$var};
        if (not $option) {
            print "ERROR: invalid option $var\n";
            return 0;
        }
        my ($type, $desc, $optfunc) = @$option;
        if ($type ne 'b' and not defined $set) {
            print "ERROR: missing = after option $var\n";
            return 0;
        }
        my $value = (defined $set) ? $set : not $opt{$var};
        if ($type eq 'i' and $value !~ /^\d+$/ and $value !~ /^0x[0-9a-f]+$/i) {
            print "ERROR: invalid number $value for option $var\n";
            return 0;
        }
        if ($optfunc and not &$optfunc($value)) {
            return 0;
        }
        $opt{$var} = $value;
        print_option($var);
    }
    return 1;
}

# -----------------------------------------------------------------
sub opt_rng {
    my ($value) = @_;
    if (not set_rng($value, $opt{seed})) {
        print "ERROR: cannot set RNG\n";
        return 0;
    }
    return 1;
}

# -----------------------------------------------------------------
sub opt_seed {
    my ($value) = @_;
    if (not set_rng($opt{rng}, $value)) {
        print "ERROR: cannot seed RNG\n";
        return 0;
    }
    return 1;
}

# -----------------------------------------------------------------
sub print_option($) {
    my ($var) = @_;
    my $option = $all_options{$var};
    return if not $option;
    my ($type, $desc) = @$option;
    print "$var = ";
    if ($type eq 'b') {
        print ($opt{$var} ? 'ON' : 'off');
    } elsif ($type eq 's') {
        print '"', $opt{$var}, '"';
    } else {
        print $opt{$var};
    }
    print "\n";
}


# -----------------------------------------------------------------
# ---- El Gamal
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# p,g,y public
# x private
sub eg_gen($) {
    my ($bits) = @_;
    my $p = find_prime($bits); # shared
    my $g = random(2, $p-1); # shared
    my $x = random(2, $p-1); # private
    my $y = pow_mod($g, $x, $p); # public
    return { 'p' => $p, 'g' => $g, 'x' => $x, 'y' => $y };
}

# -----------------------------------------------------------------
sub eg_sign($$$$) {
    my ($p,$g,$x,$msg) = @_;
    my $k = eg_k($p);
    my $r = pow_mod($g, $k, $p);
    my $ki = inv($k, $p-1);
    my $s = xmod(($msg - $x * $r) * $ki, $p-1);
    return { 'r' => $r, 's' => $s };
}

# -----------------------------------------------------------------
sub eg_verify($$$$$$) {
    my ($p,$g,$y,$r,$s,$msg) = @_;
    my $c1 = mul_mod(pow_mod($y, $r, $p), pow_mod($r, $s, $p), $p);
    my $c2 = pow_mod($g, $msg, $p);
    return ($c1 == $c2);
}

# -----------------------------------------------------------------
sub eg_encrypt($$$$) {
    my ($p,$g,$y,$msg) = @_;
    my $k = eg_k($p);
    my $r = pow_mod($g, $k, $p);
    my $s = mul_mod(pow_mod($y, $k, $p), $msg, $p);
    return { 'r' => $r, 's' => $s };
} 

# -----------------------------------------------------------------
sub eg_decrypt($$$$$) {
    my ($p,$g,$x,$r,$s) = @_;
    my $h;
    if ($opt{'slow-eg'}) {
        $h = inv(pow_mod($r, $x, $p), $p);
    } else {
        $h = pow_mod($r, $p-$x-1, $p);
    }
    return undef if not defined $h;
    return mul_mod($s, $h, $p);
}

# -----------------------------------------------------------------
sub eg_k($) {
    my ($p) = @_;
    for (;;) {
        my $k = random(2, $p-2);
        return $k if gcd($k, $p-1) == 1;
    }
}

# -----------------------------------------------------------------
# ---- RSA
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub rsa_gen($) {
    my ($bits) = @_;
    my $bits2 = rshift($bits, 1); # bits/2 for p, and bits/2 for q
    my $p = find_prime($bits2);
    my $q = find_prime($bits2);
    my $n = $p * $q; # public
    my $n1 = $opt{'orig-rsa'} ? ($p-1) * ($q-1) : lcm($p-1, $q-1);
    my $e = rsa_exponent($bits, $n1); # public
    my $d = inv($e, $n1); # private
    die "keys don't fit in $bits bits; try -e?\n" if $e >= $n or $d >= $n;
    return { 'e' => $e, 'd' => $d, 'n' => $n };
}

# -----------------------------------------------------------------
sub rsa_exponent($$) {
    my ($bits, $n1) = @_;
    my $e = $opt{'rand-rsa'} ? 0 : 65537;
    for (;;) {
        $e = random(2, $n1-1) | 1 if not $e;
        return $e if gcd($e,$n1) == 1;
        $e = 0;
    } 
}

# -----------------------------------------------------------------
sub rsa_crypt($$$) {
    my ($msg, $e, $n) = @_;
    return pow_mod($msg, $e, $n);
}

# -----------------------------------------------------------------
# --- Rabin Encryption
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub rabin_gen($) {
    my ($bits) = @_;
    return undef if not $bits;
    my $bits2 = rshift($bits, 1);
    my $p = find_blum_prime($bits2);
    my $q = find_blum_prime($bits2);
    if ($p < $q) { ($p,$q) = ($q,$p); }
    return { 'p' => $p, 'q' => $q, 'n' => $p*$q };
}

# -----------------------------------------------------------------
sub rabin_encrypt($$) {
    my ($msg, $n) = @_;
    if ($msg >= $n) {
        print "ERROR: plaintext $msg must be less than $n\n";
        return undef;
    }
    return ($msg * $msg) % $n;
}

# -----------------------------------------------------------------
# Returns four possible decryptions.
sub rabin_decrypt($$$$) {
    my ($enc, $p, $q, $n) = @_;
    if ($enc >= $n) {
        print "ERROR: encryption $enc must be less than $n\n";
        return undef;
    }
    # mp = sqrt(enc) mod p. That is, (mp*mp % p) == enc.
    my $mp = pow_mod($enc, rshift($p+1,2), $p);
    my $mq = pow_mod($enc, rshift($q+1,2), $q);

    my ($xp,$xq,$yp,$yq) = euclid($p, $q);
    die if $xp != $p or $xq != $q;

    # Use Chinese remainder theorem to find 4 candidates r1..r4.
    my $t1 = xmod($yp * $p * $mq, $n);
    my $t2 = xmod($yq * $q * $mp, $n);
    my $r1 = xmod($t1 + $t2, $n);
    my $r2 = xmod($t1 - $t2, $n);
    my $r3 = $n - $r1;
    my $r4 = $n - $r2;

    my @r = ($r1, $r2, $r3, $r4);
    return \@r;
}

# -----------------------------------------------------------------
# ---- Schnorr
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub schnorr_gen($$) {
    my ($bits, $qbits) = @_;
    # p,q,a are parameters that can be shared among different key pairs.
    my ($p,$q,$r) = find_pq_prime($bits, $qbits);
    my $a = pow_mod(3, $r, $p); # a has order q
    die if pow_mod($a, $q, $p) != 1;
    my $s = random(2, $q-1); # private key
    my $v = pow_mod(inv($a, $p), $s, $p); # public key
    return { 'p' => $p, 'q' => $q, 'a' => $a, 'qbits' => $qbits, 's' => $s, 'v' => $v };
}

sub schnorr_sign($$$$$$) {
    my ($p, $q, $a, $qbits, $s, $msg) = @_;
    my $r = random(1, $q-1);
    my $x = pow_mod($a, $r, $p);
    my $e = int_from_bytes($msg.'+'.$x, $qbits) % $q;
    my $y = ($r + $s*$e) % $q;
    return { 'e' => $e, 'y' => $y };
}

sub schnorr_verify($$$$$$$$) {
    my ($p, $q, $a, $qbits, $v, $e, $y, $msg) = @_;
    my $x = mul_mod(pow_mod($a, $y, $p), pow_mod($v, $e, $p), $p);
    my $e2 = int_from_bytes($msg.'+'.$x, $qbits) % $q;
    return $e2 == $e;
}


# -----------------------------------------------------------------
# ---- Encrypted Key Exchange
# -----------------------------------------------------------------

#
#   Es / Ds = symmetric encrypt / decrypt
#   Ea / Da = asymmetric encrypt / decrypt
#   pwd = shared password
#
#   A generates random Kpub and Kpriv keys
#   A publishes A1 = Es(pwd, Kpub)
#
#   B calculates Kpub' = Ds(pwd, A1)
#   B generates random Kb
#   B publishes B1 = Es(pwd, Ea(Kpub', Kb))
#
#   A calculates Kb' = Da(Kpriv, Ds(pwd, B1))
#   A generates random Ra
#   A publishes A2 = Es(Kb', Ra)
#
#   B calculates Ra' = Ds(Kb, A2)
#   B generates random Rb
#   B publishes B2 = Es(Kb, Ra'.Rb)
#
#   A calculates Rc = Ds(Kb', B2)
#   A verifies substr(Rc,0,len(Ra)) eq Ra
#   A calculates Rb' = substr(Rc,len(Ra))
#   A publishes A3 = Es(Kb', Rb')
#
#   B calculates Rb'' = Ds(Kb, A3)
#   B verifies Rb'' eq Rb
#
#


# -----------------------------------------------------------------
# ---- Math
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Return ($base ** $exp) % $mod, in O(lg($exp)).
sub pow_mod($$$) {
    my ($base, $exp, $mod) = @_;
    my $res = 1;
    for (; $exp != 0; $exp = rshift($exp,1)) {
        $res = mul_mod($res, $base, $mod) if ($exp & 1);
        $base = mul_mod($base, $base, $mod);
    }
    return $res;
}

# -----------------------------------------------------------------
sub mul_mod($$$) {
    my ($a, $b, $mod) = @_;
    return ($a * $b) % $mod;
}

# -----------------------------------------------------------------
# Miller-Rabin primality test.
sub is_prime($) {
    my ($num) = @_;
    my $loops = $opt{loops};

    # For efficiency, try some small prime factors first.
    return 0 if $num <= 1;
    return ($num == 2) if is_even($num);
    foreach my $p (qw(3 5 7 11 13 17 19 23 27)) {
        return 1 if $num == $p;
        return 0 if ($num % $p) == 0;
    }

    # Find s,t such that (t * 2**s == num-1), t odd.
    # ie. s is number of trailing zeros in binary representation of num-1,
    # and t is num-1 with those zeros right-shifted away.
    my $s = 0;
    my $t = $num-1;
    while (is_even($t)) {
        ++$s;
        $t = rshift($t,1);
    }

    # Repeat Miller-Rabin loops times, each with a random witness.
    while ($loops-- > 0) {
        my $a = random(2, $num-2); # witness
        my $x = pow_mod($a, $t, $num);
        return 0 if pow_mod($x, $num-1, $num) != 1;
        # Look for fake sqrt of 1: x^2 = 1 but x != +-1.
        for (my $i = 0; $i < $s; ++$i) {
            my $x2 = mul_mod($x, $x, $num);
            return 0 if $x2 == 1 and $x != 1 and $x != $num-1;
            $x = $x2;
        }
    }
    return 1; # probably prime
}

# -----------------------------------------------------------------
# Find a random prime number, a specified number of bits in length.
sub find_prime($) {
    my ($bits) = @_;
    my $m = lshift(1,$bits);
    my $n = random(rshift($m,1), $m-1) | 1;
    for (;; $n -= 2) { last if is_prime($n); }
    return $n;
}

# -----------------------------------------------------------------
sub find_blum_prime($) {
    my ($bits) = @_;
    for (;;) {
        my $p = find_prime($bits);
        return $p if ($p % 4) == 3;
    }
}

# -----------------------------------------------------------------
# Return (p,q,r) such that p is prime, q is prime and p = qr+1.
sub find_pq_prime($$) {
    my ($bits, $qbits) = @_;
    my $rmax = lshift(1,$bits-$qbits-1)-1;
    my $rmin = rshift($rmax,1);
    for (;;) {
        my $q = find_prime($qbits); # pick the large factor first
        my $r = random($rmin, $rmax);
        my $p = ($q*$r)+1;
        return ($p,$q,$r) if is_prime($p);
    }
}

# -----------------------------------------------------------------
# Extended Euclidean algorithm.
# euclid(u,v) returns (w,x,a,b,g,k) such that
#   w = u>>k, x = v>>k, , u = w<<k, v = x<<k, w,x not both even
#   g = gcd(u,v) = a*w - b*x = (a>>k)*u - (b>>k)*v
sub euclid($$) {
    my ($u, $v) = @_;
    if ($u < $v) { ($u,$v) = ($v,$u); }
    my $k = 0;
    for (; is_even($u) and is_even($v); ++$k) {
        $u = rshift($u,1); $v = rshift($v,1);
    }
    my ($u1, $u2, $u3, $v1, $v2, $v3) = (1, 0, $u, $v, $u-1, $v);
    do {
        do {
            if (is_even($u3)) {
                if (not is_even($u1) or not is_even($u2)) {
                    $u1 += $v; $u2 += $u;
                }
                $u1 = rshift($u1,1); $u2 = rshift($u2,1); $u3 = rshift($u3,1);
            }
            if (is_even($v3) or $u3 < $v3) { # swap u* with v*
                ($u1,$u2,$u3,$v1,$v2,$v3) = ($v1,$v2,$v3,$u1,$u2,$u3);
            }
        } while (is_even($u3));
        while ($u1 < $v1 or $u2 < $v2) {
            $u1 += $v; $u2 += $u;
        }
        $u1 -= $v1; $u2 -= $v2; $u3 -= $v3;
    } while ($v3 > 0); 
    while ($u1 >= $v and $u2 >= $u) {
        $u1 -= $v; $u2 -= $u;
    }
    $u1 = lshift($u1,$k); $u2 = lshift($u2,$k); $u3 = lshift($u3,$k);
    return ($u, $v, $u1, $u2, $u3, $k);
}

# -----------------------------------------------------------------
# Return (u^-1 % v); that is, x such that u*x % v == 1.
sub inv($$) {
    my ($u, $v) = @_;
    my ($u2,$v2,$a,$b,$gcd) = euclid($u, $v);
    return undef if $gcd != 1; # no inverse
    return $u2 - $b;
}

# -----------------------------------------------------------------
# Return greatest common divisor of u and v.
sub gcd($$) {
    my ($u, $v) = @_;
    my ($u2,$v2,$a,$b,$gcd) = euclid($u, $v);
    return $gcd;
}

# -----------------------------------------------------------------
# Return least common multiple of u and v.
sub lcm($$) {
    my ($u, $v) = @_;
    my $gcd = gcd($u, $v);
    return undef if not $gcd;
    return new Math::BigInt(($u * $v) / $gcd); # Makes a BigFloat without this nonsense!
}

# -----------------------------------------------------------------
sub is_even($) {
    my ($n) = @_;
    return ($n & 1) == 0;
}

# -----------------------------------------------------------------
# Return random integer between $min and $max inclusive.
# Get random bytes and do arithmetic.
sub random($$) {
    my ($min, $max) = @_;
    return $min if $min >= $max;
    my $m = $max - $min + 1;
    my $bytes = 1 + int(log($m) / log(256));
    my $rand = $rng->{get}($rng, $bytes);
    my $n = 0;
    for (my $i = 0; $i < $bytes; ++$i) {
        $n = lshift($n,8) + ord(substr($rand,$i,1));
    }
    # FIXME: mod here is biased.
    $n = ($n % $m);
    return $min + $n;
}

# -----------------------------------------------------------------
# Standard RNG. Uses rand().
sub std_rng_init($;$) {
    my ($bits, $seed) = @_;
    if ($seed and length($seed) > 0) {
        srand(int_from_bytes($seed, $bits));
    }
    return { 'get' => \&std_rng_get };
}

sub std_rng_get($$) {
    my ($std, $bytes) = @_;
    my $data = '';
    while (length($data) < $bytes) {
        $data .= chr(int(rand(0x1000000)) >> 8);
    }
    return $data;
}

# -----------------------------------------------------------------
# Secure RNG. Uses Math::Random::Secure.
sub sec_rng_init($;$) {
    my ($bits, $seed) = @_;
    if (not eval "require Math::Random::Secure") {
        print "Math::Random::Secure module not found\n";
        return undef;
    }
    if ($seed and length($seed) > 0) {
        Math::Random::Secure::srand($seed);
    }
    return { 'get' => \&sec_rng_get };
}

sub sec_rng_get($$) {
    my ($sec, $bytes) = @_;
    my $data = '';
    while (length($data) < $bytes) {
        $data .= chr(Math::Random::Secure::irand() & 0xff);
    }
    return $data;
}

# -----------------------------------------------------------------
# Blum-Blum-Shub RNG.
sub bbs_rng_init($;$) {
    my ($bits, $seed) = @_;
    $seed = 1 if not $seed;
    $rng = std_rng_init($bits, $seed); # bizarre that BBS needs another RNG
    my $rabin = rabin_gen($bits);
    return undef if not $rabin;
    my $rn = $rabin->{n};
    my $x = int_from_bytes($seed, $bits) % $rn;
    while (gcd($x, $rn) != 1) {
        return undef if not $x;
        --$x;
    }
    return { 'get' => \&bbs_rng_get, 'n' => $rn, 'x' => $x };
}

sub bbs_rng_get($$) {
    my ($bbs, $bytes) = @_;
    my $byte = 0;
    my $bytebits = 0;
    my $data = '';
    my $n = $bbs->{n};
    my $x = $bbs->{x};
    while (length($data) < $bytes) {
        $x = ($x * $x) % $n;
        $byte = lshift($byte,1) | ($x & 1);
        if (++$bytebits == 8) {
            $data .= chr $byte;
            $byte = 0;
            $bytebits = 0;
        }
    }
    $bbs->{x} = $x;
    return $data;
}

# -----------------------------------------------------------------
# Diffie-Hellman key exchange
sub dh_key_exchange($) {
    my ($bits) = @_;
    my $base = 3;
    my $mod = find_prime($bits);
    my $sa = random(rshift($mod,1), $mod-1);
    my $sb = random(rshift($mod,1), $mod-1);
    my $pa = pow_mod($base, $sa, $mod);
    my $pb = pow_mod($base, $sb, $mod);
    my $ab = pow_mod($pb, $sa, $mod);
    my $ba = pow_mod($pa, $sb, $mod);

    print "A and B agree on base $base and modulus $mod\n";
    print "A generates secret $sa\n";
    print "B generates secret $sb\n";
    print "A calculates $base^$sa mod $mod = $pa and publishes it\n";
    print "B calculates $base^$sb mod $mod = $pb and publishes it\n";
    print "A calculates shared $pb^$sa mod $mod = $ab\n";
    print "B calculates shared $pa^$sb mod $mod = $ba\n";
}

# -----------------------------------------------------------------
# Standard (Luhn) credit card check digit.
sub luhn($;$) {
    my ($ccn, $gen) = @_;
    my $total = 0;
    $ccn .= '0' if $gen;
    for (my $i = 0; $i < length($ccn); ++$i) {
        my $digit = ord(substr($ccn, length($ccn)-$i-1, 1)) - ord('0');
        return undef if $digit < 0 or $digit >= 10;
        $digit *= 2 if $i & 1;
        $digit -= 9 if $digit > 9;
        $total += $digit;
    }
    $total %= 10;
    $total = 10 - $total if $gen and $total > 0;
    return $total;
}

# -----------------------------------------------------------------
# Verhoeff credit card check digit.
sub verhoeff($;$) {
    my ($ccn, $gen) = @_;
    my @d = (
        [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
        [ 1, 2, 3, 4, 0, 6, 7, 8, 9, 5 ],
        [ 2, 3, 4, 0, 1, 7, 8, 9, 5, 6 ],
        [ 3, 4, 0, 1, 2, 8, 9, 5, 6, 7 ],
        [ 4, 0, 1, 2, 3, 9, 5, 6, 7, 8 ],
        [ 5, 9, 8, 7, 6, 0, 4, 3, 2, 1 ],
        [ 6, 5, 9, 8, 7, 1, 0, 4, 3, 2 ],
        [ 7, 6, 5, 9, 8, 2, 1, 0, 4, 3 ],
        [ 8, 7, 6, 5, 9, 3, 2, 1, 0, 4 ],
        [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ],
    );
    my @p = (
        [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
        [ 1, 5, 7, 6, 2, 8, 3, 0, 9, 4 ],
        [ 5, 8, 0, 3, 7, 9, 6, 1, 4, 2 ],
        [ 8, 9, 1, 6, 0, 4, 3, 5, 2, 7 ],
        [ 9, 4, 5, 3, 1, 2, 6, 8, 7, 0 ],
        [ 4, 2, 8, 6, 5, 7, 3, 9, 0, 1 ],
        [ 2, 7, 9, 3, 8, 0, 6, 4, 1, 5 ],
        [ 7, 0, 4, 6, 9, 1, 3, 2, 5, 8 ],
    );
    my @inv = ( 0, 4, 3, 2, 1, 5, 6, 7, 8, 9 );

    $ccn .= '0' if $gen;
    my $total = 0;
    for (my $i = 0; $i < length($ccn); ++$i) {
        my $digit = ord(substr($ccn, length($ccn)-$i-1, 1)) - ord('0');
        return undef if $digit < 0 or $digit >= 10;
        my $p = ${$p[$i % 8]}[$digit];
        $total = ${$d[$total]}[$p];
    }
    $total = $inv[$total] if $gen;
    return $total;
}

# -----------------------------------------------------------------
# Fisher-Yates
sub shuffle($) {
    my ($list) = @_;
    for (my $i = @$list-1; $i > 0; --$i) {
        my $j = random(0,$i);
        ($$list[$i], $$list[$j]) = ($$list[$j], $$list[$i]);
    }
}

# -----------------------------------------------------------------
# ---- Misc
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub args(+@) {
    my $args = shift @_;
    my @rargs;
    push @rargs, shift @$args;
    foreach my $arg (@$args) {
        if ($arg eq '-') {
            foreach my $var (@_) {
                push @rargs, $$saved{$var};
            }
        ## } elsif ($arg =~ /^-([a-z]+)/) {
        ##     $flags .= $1;
        } else {
            my $val = i($arg);
            return undef if not defined $val;
            push @rargs, $val;
        }
    }
    return @rargs;
}


# -----------------------------------------------------------------
sub int_from_bytes($$) {
    my ($data, $bits) = @_;
    die if not $bits;
    my $hash = Digest::SHA::sha256($data);
    my $num = 0;
    for (my $i = 0; $i < $bits; ++$i) {
        my $bit = (ord(substr($hash, int($i/8), 1)) >> ($i%8)) & 1;
        $num |= lshift($bit, $i);
    }
    ## $num = -$num if $num < 0;
    return $num;
}

# -----------------------------------------------------------------
sub i($) {
    my ($s) = @_;
    return hex($s) if $s =~ /^0x/i;
    return $s+0 if $s =~ /^\d+$/; # force to a BigInt
    return undef;
}

# -----------------------------------------------------------------
sub number($) {
    my ($n) = @_;
    return $n->as_hex() if $opt{x};
    return $n;
}

# -----------------------------------------------------------------
sub print_map(+@) {
    my $map = shift @_;
    foreach my $key (@_) {
        print $key, '= ', number($$map{$key}), "\n";
    }
}

# -----------------------------------------------------------------
sub lshift($$) {
    my ($n, $shift) = @_;
    return int($n << $shift);
}

# -----------------------------------------------------------------
sub rshift($$) {
    my ($n, $shift) = @_;
    return int($n >> $shift);
}

# -----------------------------------------------------------------
sub rmask($) {
    my ($n) = @_;
    return (lshift(1, $n) - 1);
}

# -----------------------------------------------------------------
# Make sure mod does the right thing with negative numbers.
sub xmod($$) {
    my ($n, $m) = @_;
    return $n % $m if $n >= 0;
    my $a = (int(-$n/$m)+2) * $m;
    return ($n + $a) % $m;
}

# -----------------------------------------------------------------
sub print_bin($) {
    my ($data) = @_;
    for (my $i = 0; $i < length $data; ++$i) {
        my $ch = substr($data, $i, 1);
        printf " %02x", ord $ch;
    }
}

# -----------------------------------------------------------------
sub save_obj(%) {
    my ($old) = @_;
    my %new;
    while (my ($k,$v) = each %$old) {
        $new{$k} = $v;
    }
    $saved = \%new;
}
