#!/usr/bin/perl

# Sample code for cryptographic operations.

use strict;
use bignum;
use Getopt::Long;
use Digest::SHA;
use Time::HiRes      qw( time );
use List::Util       qw( min max );
use List::MoreUtils  qw( first_index );

# Constants
my $rng_bits_default    = 32;
my $mr_loops_default    = 8;
my $rabin_shift_default = 8;
my $qs_pivot_default    = 'mid';

my %set_alias = ( 'on' => 1, 'off' => 0 );
my %pivot_alias = ( 'lo' => 1, 'hi' => 2, 'mid' => 3, 'med3' => 4 );

my %all_rngs = (
    'std' => \&std_rng_init, 
    'sec' => \&sec_rng_init, 
    'bbs' => \&bbs_rng_init, 
    'sim' => \&sim_rng_init, 
    'twi' => \&twi_rng_init, 
);

my %all_options = (
    'cards'       => [ 'b', "Print playing cards in Solitaire." ],
    'eg-slow'     => [ 'b', "Don't use Lagrange Theorem shortcut to compute mult. inverse." ],
    'hex'         => [ 'b', "Print numbers in hex." ],
    'loops'       => [ 'i', "Number of loops in Miller-Rabin (default $mr_loops_default)." ],
    'no-prompt'   => [ 'b', "Don't print prompts." ],
    'perf'        => [ 'b', "Print performance stats." ],
    'qs-pivot'    => [ 's', "QuickSort pivot (".join(',',sort keys %pivot_alias).")." ],
    'rabin-raw'   => [ 'b', "Don't pad message; decryption prints all 4 candidates." ],
    'rabin-shift' => [ 'i', "Bits to use for Rabin disambiguation (default $rabin_shift_default)." ],
    'rng'         => [ 's', "Random number generator (".join(',',sort keys %all_rngs)."). Optional bits follows colon (eg. \"bbs:64\").", \&opt_rng ],
    'rsa-orig'    => [ 'b', "Use phi rather than lambda in calculating decryption exponent." ],
    'rsa-randexp' => [ 'b', "Use random encrytion exponent rather than 65537." ],
    'seed'        => [ 's', "Seed string for RNG. \"NUM\@FILE\" to read NUM bytes from FILE.", \&opt_seed ],
    'verbose'     => [ 'b', "Print debugging info." ],
);

my %all_commands = (
    'bg-decrypt'      => [ \&cmd_bg_decrypt,      "{P Q N} H T X C" ],
    'bg-encrypt'      => [ \&cmd_bg_encrypt,      "{N} MSG" ],
    'bg-gen'          => [ \&cmd_bg_gen,          "BITS QBITS" ],
    'cs-decrypt'      => [ \&cmd_cs_decrypt,      "[P Q QBITS G1 G2 C D H] MSG" ],
    'cs-encrypt'      => [ \&cmd_cs_encrypt,      "[P X1 X2 Y1 Y2 Z] U1 U2 E V" ],
    'cs-gen'          => [ \&cmd_cs_gen,          "BITS" ],
    'eg-decrypt'      => [ \&cmd_eg_decrypt,      "{P G X} R S" ],
    'eg-encrypt'      => [ \&cmd_eg_encrypt,      "{P G Y} MSG" ],
    'eg-gen'          => [ \&cmd_eg_gen,          "BITS" ],
    'eg-sign'         => [ \&cmd_eg_sign,         "{P G X} MSG" ],
    'eg-verify'       => [ \&cmd_eg_verify,       "{P G Y} R S MSG" ],
    'euclid'          => [ \&cmd_euclid,          "NUM1 NUM2" ],
    'find-prime'      => [ \&cmd_find_prime,      "BITS" ],
    'find-pq-prime'   => [ \&cmd_find_pq_prime,   "BITS QBITS" ],
    'gcd'             => [ \&cmd_gcd,             "NUM1 NUM2" ],
    'help'            => [ \&cmd_help,            "[command]" ],
    'inv'             => [ \&cmd_inv,             "NUM MOD" ],
    'is-prime'        => [ \&cmd_is_prime,        "NUM" ],
    'isort'           => [ \&cmd_sort,            "NUM..." ],
    'ibsort'          => [ \&cmd_sort,            "NUM..." ],
    'kx'              => [ \&cmd_kx,              "BITS" ],
    'lcm'             => [ \&cmd_lcm,             "NUM1 NUM2" ],
    'luhn'            => [ \&cmd_ccn,             "[-g] CCN" ],
    'mul'             => [ \&cmd_mul,             "N1 N2 MOD" ],
    'msort'           => [ \&cmd_sort,            "NUM..." ],
    'option'          => [ \&cmd_option,          "[+!_]OPTION[=VALUE]..." ],
    'pow'             => [ \&cmd_pow,             "BASE EXP MOD" ],
    'rabin-decrypt'   => [ \&cmd_rabin_decrypt,   "{P Q N} MSG" ],
    'rabin-encrypt'   => [ \&cmd_rabin_encrypt,   "{N} MSG" ],
    'rabin-gen'       => [ \&cmd_rabin_gen,       "BITS [SIGN_NONCE_BITS]" ],
    'rabin-sign'      => [ \&cmd_rabin_sign,      "{P Q N BITS SIGN_NONCE_BITS} MSG" ],
    'rabin-verify'    => [ \&cmd_rabin_verify,    "{N BITS} U X MSG" ],
    'random'          => [ \&cmd_random,          "MIN MAX" ],
    'random-bytes'    => [ \&cmd_random_bytes,    "BYTES" ],
    'rsa-decrypt'     => [ \&cmd_rsa_decrypt,     "{N D} MSG" ],
    'rsa-encrypt'     => [ \&cmd_rsa_encrypt,     "{N E} MSG" ],
    'rsa-gen'         => [ \&cmd_rsa_gen,         "BITS" ],
    'qsort'           => [ \&cmd_sort,            "NUM..." ],
    'schnorr-gen'     => [ \&cmd_schnorr_gen,     "BITS QBITS" ],
    'schnorr-sign'    => [ \&cmd_schnorr_sign,    "{P Q A QBITS S} MSG" ],
    'schnorr-verify'  => [ \&cmd_schnorr_verify,  "{P Q A QBITS V} E Y MSG" ],
    'shuffle'         => [ \&cmd_shuffle,         "NUM" ],
    'sol-decrypt'     => [ \&cmd_sol_crypt,       "[-k KEY | SHUFFLE] MSG" ],
    'sol-encrypt'     => [ \&cmd_sol_crypt,       "[-k KEY | SHUFFLE] MSG" ],
    'verhoeff'        => [ \&cmd_ccn,             "[-g] CCN" ],
);

# For Solitaire.
my $suit_cards   = 52;
my $jokers       = 2;
my $jokerA       = $suit_cards+1;
my $jokerB       = $jokerA+1;

# Global variables.
my $rng; # the active RNG, returned from *_rng_init
my %opt; # currently set options
my $saved;


# -----------------------------------------------------------------
# Print usage.
# cmd = NAME    : Print usage for command NAME.
# cmd = ''      : Print usage for all commands.
# cmd = 'shell' : Print usage for command line and all commands.
sub usage(;$) {
    my ($cmd) = @_;
    my $opts_prt = 0;
    if ($cmd eq 'shell') {
        print "usage: crypto [options] [--] [command args... [{';'|'&'} command args...]...]\n";
        print " options:\n";
        usage_options(1);
        $opts_prt = 1;
        $cmd = '';
    }
    if ($cmd) {
        my $command = $all_commands{$cmd};
        if (not $command) {
            print "invalid command \"$cmd\"\n";
        } else {
            usage_cmd($cmd, $command, 0);
        }
    } else { # all commands
        print " commands: (values in {} may be '-' if preceded by *-gen)\n";
        foreach my $wcmd (sort keys %all_commands) {
            usage_cmd($wcmd, $all_commands{$wcmd}, $opts_prt);
        }
    }
    return 0;
}

# -----------------------------------------------------------------
sub usage_cmd($$$) {
    my ($cmd, $command, $opts_prt) = @_;
    my ($handler, $args) = @$command;
    print "  $cmd $args\n";
    usage_options(0) if $cmd eq 'option' and not $opts_prt;
}

# -----------------------------------------------------------------
sub usage_options {
    my ($dashes) = @_;
    my $dash = $dashes ? '--' : '';
    foreach my $var (sort keys %all_options) {
        my $option = $all_options{$var};
        my ($type, $desc) = @$option;
        printf "    $dash%-13s %s\n", $var . ($type eq 'b' ? ' ' : '='), $desc;
    }
}

# -----------------------------------------------------------------
exit (main() ? 0 : 1);
sub main {
    my @alist; # list of all option names for GetOptions
    while (my ($var,$option) = each %all_options) {
        my ($type) = @$option;
        $var .= "=$type" unless $type eq 'b';
        push @alist, $var;
    }
    return usage('shell') if not GetOptions(\%opt, @alist);
    $opt{loops} = $mr_loops_default if not $opt{loops};
    $opt{'rabin-shift'} = $rabin_shift_default if not $opt{'rabin-shift'};
    $opt{rng} = 'std' if not $opt{rng};
    $opt{seed} = time() if not $opt{seed};
    $opt{'qs-pivot'} = $pivot_alias{$opt{'qs-pivot'} or $qs_pivot_default};
    return usage() if not $opt{'qs-pivot'};
    return usage() if not set_rng($opt{rng}, $opt{seed});

    # Change 'crypto help' to 'crypto help shell'.
    if (@ARGV == 1 and $ARGV[0] eq 'help') { push @ARGV, 'shell'; }

    return command(@ARGV) if @ARGV; # crypto command is on cmd line

    # Interactive mode.
    my $ok = 1;
    my $prev_line = '';
    for (;;) {
        printf "> " unless $opt{'no-prompt'};
        my $line = <>;
        last if not defined $line;
        $line =~ s/^\s+//; # rm leading space
        $line =~ s/\s+$//; # rm trailing space, \r, \n
        next if $line eq ''; # ignore empty line
        next if $line =~ /^#/; # ignore comment
        last if $line eq 'q' or $line eq 'quit' or $line eq 'exit';
        $line = $prev_line if $line eq '!!';
        $prev_line = $line;
        # Split line on spaces and quotes, then rejoin any quoted parts.
        my @args;
        my $quoting = 0;
        my $word = '';
        foreach my $arg (split /(\s+|")/, $line.' ') {
            if ($arg eq '"') {
                $quoting = not $quoting;
            } elsif ($quoting) { # add everything to word while quoting
                $word .= $arg;
            } elsif ($arg !~ /^\s*$/) { # add nonspace string to word
                $word .= $arg; 
            } elsif ($arg =~ /\s+/) { # unquoted space = end of word
                push @args, $word;
                $word = '';
            }
        }
        if (not command(@args)) {
            print "*** command failed\n" unless $opt{'no-prompt'};
            $ok = 0;
        }
    }
    return $ok;
}

# -----------------------------------------------------------------
sub set_rng($$) {
    my ($rname, $seed) = @_;
    my $bits = $rng_bits_default;
    if ($rname =~ /^ ([^:]+) : (\d+)$ /x) {
        ($rname, $bits) = ($1,$2);
    }
    if ($seed =~ /^(\d{1,12})\@(\S+)$/) {
        $seed = read_file($2, $1);
        return 0 if not defined $seed;
        print "seed from $2: "; print_bin($seed); print "\n";
    }
    my $rng_init = $all_rngs{$rname};
    if (not $rng_init) {
        print "ERROR: invalid RNG \"$rname\"\n";
        return 0;
    }
    my $new_rng = &$rng_init($bits, $seed);
    return 0 if not $new_rng;
    $new_rng->{name} = $rname;
    $rng = $new_rng;
    ##print "RNG: $rname:$bits\n";
    return 1;
}

# -----------------------------------------------------------------
sub command(@) {
    my $ret = 1;
    while (@_) {
        my $cmd = $_[0];
        my $command = $all_commands{$cmd};
        if (not $command) {
            print "invalid command \"$cmd\"; use \"help\" for help\n";
            last;
        }
        # See if there is a termchar (';' or '&').
        my $end = first_index { $_ eq ';' or $_ eq '&' } @_;
        $end = scalar(@_) if $end < 0;
        my $termchar = ($end < @_) ? $_[$end] : '';
        my @args = splice @_, 0, $end;
        my $quit_on_error = 0;
        if ($termchar) {
            die if $termchar ne shift(@_); # discard termchar
            $quit_on_error = 1 if $termchar eq '&';
        }
        my ($handler) = @$command;
        my $start_time = time();
        $ret = &$handler(@args); # run the cmd
        printf "=%.6f sec\n", time()-$start_time if $opt{perf};
        last if not $ret and $quit_on_error;
    }
    return $ret;
}

# -----------------------------------------------------------------
sub cmd_fail($) {
    my ($cmd) = @_;
    print "$cmd failed\n";
    return 0;
}

# -----------------------------------------------------------------
sub cmd_help {
    my ($cmd, $help_cmd) = @_;
    usage($help_cmd);
    return 1;
}

# -----------------------------------------------------------------
sub cmd_euclid {
    my ($cmd, $u, $v) = args(\@_);
    return usage($cmd) if not defined $v;
    if ($u < $v) { ($u,$v) = ($v,$u); }
    my ($w,$x,$a,$b,$gcd,$k) = euclid($u, $v);
    my $ngcd = number($gcd);
    print $ngcd, ' = ', number($a), ' * ', number($w), ' - ', number($b), ' * ', number($x), "\n";
    if ($k > 0) {
        print (' ' x length($ngcd));
        print ' = (', number($a), ' * ', number($u), ' - ', number($b), ' * ', number($v), ') >> ', number($k), "\n";
    }
    if ($gcd == 1) {
        print number($x), '^-1 mod ', number($w), ' = ', number($w-$b), "\n";
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_pow {
    my ($cmd, $base, $exp, $mod) = args(\@_);
    return usage($cmd) if not $mod;
    my $n = pow_mod($base, $exp, $mod);
    print number($n), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_mul {
    my ($cmd, $n1, $n2, $mod) = args(\@_);
    return usage($cmd) if not $mod;
    my $n = mul_mod($n1, $n2, $mod);
    print number($n), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_find_prime {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits;
    my $n = find_prime($bits);
    print number($n), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_find_pq_prime {
    my ($cmd, $bits, $qbits) = args(\@_);
    return usage($cmd) if not $qbits;
    my ($p,$q,$r) = find_pq_prime($bits, $qbits);
    print number($p), ' = ', number($q), ' * ', number($r), " +1\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_is_prime {
    my ($cmd, $num) = args(\@_);
    return usage($cmd) if not $num;
    print is_prime($num) ? "probably prime\n" : "composite\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_gcd {
    my ($cmd, $u, $v) = args(\@_);
    return usage($cmd) if not defined $v;
    my $gcd = gcd($u, $v);
    print number($gcd), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_inv {
    my ($cmd, $num, $mod) = args(\@_);
    return usage($cmd) if not defined $mod;
    my $inv = inv($num, $mod);
    print number($inv), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_lcm {
    my ($cmd, $u, $v) = args(\@_);
    return usage($cmd) if not defined $v;
    my $lcm = lcm($u, $v);
    print number($lcm), "\n";
    return 1;
}

# -----------------------------------------------------------------
# Return a and b such that a*p - b*q = 1.
sub euclid_pair {
    my ($p, $q) = @_;
    my $swap = ($p < $q);
    if ($swap) { ($p,$q) = ($q,$p); }
    my ($xp,$xq,$a,$b) = euclid($p, $q);
    die if $xp != $p or $xq != $q;
    if ($swap) { ($a,$b) = (-$b,-$a); }
    return ($a, $b);
}

# -----------------------------------------------------------------
sub cmd_random {
    my ($cmd, $min, $max) = args(\@_);
    return usage($cmd) if not $max;
    my $n = random($min, $max);
    return cmd_fail("RNG($rng->{name})") if not defined $n;
    print number($n), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_random_bytes {
    my ($cmd, $bytes) = args(\@_);
    return usage($cmd) if not $bytes;
    my $data = $rng->{get}($rng, $bytes);
    return cmd_fail("RNG($rng->{name})") if not $data;
    print_bin($data);
    print "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_shuffle {
    my ($cmd, $num) = args(\@_);
    return usage($cmd) if not $num;
    my @nums = 1 .. $num;
    shuffle(\@nums);
    print join(' ', @nums), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_sort {
    my ($cmd, @list) = args(\@_);
    return usage($cmd) if not @list;
    my @sorted =
        ($cmd eq 'isort') ? insertl_sort(@list) :
        ($cmd eq 'ibsort') ? insertb_sort(@list) :
        ($cmd eq 'msort') ? merge_sort(@list) :
        ($cmd eq 'qsort') ? quick_sort(@list) :
        ();
    print join(' ', @sorted), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rsa_gen {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits or $bits < 3;
    my $rsa = rsa_gen($bits);
    return 0 if not $rsa;
    save_obj($rsa);
    print_map($rsa, 'e','d','n');
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rsa_encrypt {
    my ($cmd, $n,$e,$msg) = args(\@_, 'n','e');
    return usage($cmd) if not $n or not $e or not defined $msg;
    my $num = rsa_crypt($msg, $e, $n);
    print number($num), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rsa_decrypt {
    my ($cmd, $n,$d,$msg) = args(\@_, 'n','d');
    return usage($cmd) if not $n or not $d or not defined $msg;
    my $num = rsa_crypt($msg, $d, $n);
    print number($num), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_gen {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits or $bits < 3;
    my $eg = eg_gen($bits);
    return 0 if not $eg;
    save_obj($eg);
    print_map($eg, 'p','g','y','x');
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_sign {
    my ($cmd, $p,$g,$x,$msg) = args(\@_, 'p','g','x');
    return usage($cmd) if not $msg;
    my $sig = eg_sign($p,$g,$x,$msg);
    return cmd_fail('sign') if not $sig;
    print number($$sig{r}), ' ', number($$sig{s}), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_verify {
    my ($cmd, $p,$g,$y,$r,$s,$msg) = args(\@_, 'p','g','y');
    return usage($cmd) if not $s;
    return cmd_fail('verify') if not eg_verify($p,$g,$y,$r,$s,$msg);
    print "ok\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_encrypt {
    my ($cmd, $p,$g,$y,$msg) = args(\@_, 'p','g','y');
    return usage($cmd) if not $msg;
    my $enc = eg_encrypt($p,$g,$y,$msg);
    return cmd_fail('encrypt') if not $enc;
    print number($$enc{r}), ' ', number($$enc{s}), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_eg_decrypt {
    my ($cmd, $p,$g,$x,$r,$s) = args(\@_, 'p','g','x');
    return usage($cmd) if not $s;
    my $msg = eg_decrypt($p,$g,$x,$r,$s);
    return cmd_fail('decrypt') if not defined $msg;
    print number($msg), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_bg_gen {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits;
    my $bg = bg_gen($bits);
    return 0 if not $bg;
    save_obj($bg);
    print_map($bg, 'p','q','n');
    return 1;
}

# -----------------------------------------------------------------
sub cmd_bg_encrypt {
    my ($cmd, $n,$msg) = args(\@_, 'n');
    return usage($cmd) if not $n or not defined $msg;
    my $enc = bg_encrypt($n, $msg);
    return cmd_fail('encrypt') if not defined $enc;
    print number($$enc{h}), ' ', number($$enc{t}), ' ', number($$enc{xt}), ' ', number($$enc{c}), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_bg_decrypt {
    my ($cmd, $p,$q,$n,$h,$t,$xt,$c) = args(\@_, 'p','q','n');
    return usage($cmd) if not $p or not $q or not defined $c;
    my $dec = bg_decrypt($p, $q, $n, $h, $t, $xt, $c);
    return cmd_fail('decrypt') if not defined $dec;
    print number($dec), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_cs_gen {
    my ($cmd, $bits, $qbits) = args(\@_);
    return usage($cmd) if not $bits or not $qbits;
    my $cs = cs_gen($bits, $qbits);
    return 0 if not $cs;
    $$cs{qbits} = $qbits;
    save_obj($cs);
    print_map($cs, 'p','q','qbits','g1','g2','c','d','h','x1','x2','y1','y2','z');
    return 1;
}

# -----------------------------------------------------------------
sub cmd_cs_encrypt {
    my ($cmd, $p, $q, $qbits, $g1, $g2, $c, $d, $h, $msg) = args(\@_, 'p','q','qbits','g1','g2','c','d','h');
    return usage($cmd) if not defined $msg;
    my $enc = cs_encrypt($p, $q, $qbits, $g1, $g2, $c, $d, $h, $msg);
    return cmd_fail('encrypt') if not defined $enc;
    print number($$enc{u1}), ' ', number($$enc{u2}), ' ', number($$enc{e}), ' ', number($$enc{v}), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_cs_decrypt {
    my ($cmd, $p, $q, $qbits, $x1, $x2, $y1, $y2, $z, $u1, $u2, $e, $v) = args(\@_, 'p','q','qbits','x1','x2','y1','y2','z');
    return usage($cmd) if not defined $v;
    my $dec = cs_decrypt($p, $q, $qbits, $x1, $x2, $y1, $y2, $z, $u1, $u2, $e, $v);
    return cmd_fail('decrypt') if not defined $dec;
    print number($dec), "\n";
    return 1;
}


# -----------------------------------------------------------------
sub cmd_rabin_gen {
    my ($cmd, $bits, $sign_nonce_bits) = args(\@_);
    return usage($cmd) if not $bits;
    $bits += $opt{'rabin-shift'} unless $opt{'rabin-raw'};
    my $rabin = rabin_gen($bits, $sign_nonce_bits);
    return 0 if not $rabin;
    save_obj($rabin);
    print_map($rabin, 'p','q','n');
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rabin_encrypt {
    my ($cmd, $n,$msg) = args(\@_, 'n');
    return usage($cmd) if not $n or not defined $msg;
    # Use N low order zero bits to distinguish between 4 posssible decryptions.
    $msg = lshift($msg, $opt{'rabin-shift'}) unless $opt{'rabin-raw'};
    my $enc = rabin_encrypt($n, $msg);
    return cmd_fail('encrypt') if not defined $enc;
    print number($enc), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rabin_decrypt {
    my ($cmd, $p,$q,$n,$enc) = args(\@_, 'p','q','n');
    return usage($cmd) if not $p or not $q or not defined $enc;
    # Look for the correct decryption among the 4.
    my @decs = rabin_decrypt($p, $q, $n, $enc);
    return cmd_fail('decrypt') if not @decs;

    my $rabin_shift = $opt{'rabin-shift'};
    foreach my $m (@decs) {
        if ($opt{'rabin-raw'}) { # just print them all.
            print number($m), "\n";
        } elsif (($m & rmask($rabin_shift)) == 0) {
            # Found one with N low order zero bits.
            # It might be the right decryption (or we might be very unlucky).
            print number(rshift($m, $rabin_shift)), "\n";
        }
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rabin_sign {
    my ($cmd, $p,$q,$n,$bits,$sign_nonce_bits, $msg) = args(\@_, 'p','q','n','bits','sign_nonce_bits');
    return usage($cmd) if not $msg;
    my $sig = rabin_sign($p, $q, $n, $bits, $sign_nonce_bits, $msg);
    return cmd_fail('sign') if not $sig;
    print number($$sig{u}), ' ', number($$sig{x}), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_rabin_verify {
    my ($cmd, $n,$bits,$u,$x, $msg) = args(\@_, 'n','bits');
    return usage($cmd) if not $msg;
    return cmd_fail('verify') if not rabin_verify($n,$bits,$u,$x,$msg);
    print "ok\n";
    return 1;
}


# -----------------------------------------------------------------
sub cmd_schnorr_gen {
    my ($cmd, $bits, $qbits) = args(\@_);
    return usage($cmd) if not $bits or not $qbits or $qbits >= $bits;
    my $sch = schnorr_gen($bits, $qbits);
    return 0 if not $sch;
    save_obj($sch);
    print_map($sch, 'p','q','a','qbits','s','v');
    return 1;
}

# -----------------------------------------------------------------
sub cmd_schnorr_sign {
    my ($cmd, $p,$q,$a,$qbits,$s,$msg) = args(\@_, 'p','q','a','qbits','s');
    return usage($cmd) if not $msg;
    my $sig = schnorr_sign($p,$q,$a,$qbits,$s,$msg);
    return cmd_fail('sign') if not $sig;
    print number($$sig{e}), ' ', number($$sig{y}), "\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_schnorr_verify {
    my ($cmd, $p,$q,$a,$qbits,$v,$e,$y,$msg) = args(\@_, 'p','q','a','qbits','v');
    return usage($cmd) if not $msg;
    return cmd_fail('verify') if not schnorr_verify($p,$q,$a,$qbits,$v,$e,$y,$msg);
    print "ok\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_sol_crypt {
    my ($cmd, $deck, $msg, $msg2) = @_;
    if ($deck eq '-k') {
        $deck = sol_deck_from_key($msg);
        $msg = $msg2;
    } else {
        my @deck = split /[\s,]/, $deck;
        $deck = \@deck;
    }
    return usage($cmd) if not defined $msg or scalar(@$deck) != 54;
    # Should check that deck is a permutation of 1..54
    my $crypt = sol_crypt(($cmd eq 'sol-encrypt'), $deck, $msg);
    return cmd_fail($cmd) if not defined $crypt;
    print "$crypt\n";
    return 1;
}

# -----------------------------------------------------------------
sub cmd_kx {
    my ($cmd, $bits) = args(\@_);
    return usage($cmd) if not $bits;
    dh_key_exchange($bits);
    return 1;
}

# -----------------------------------------------------------------
sub cmd_ccn {
    my ($cmd, $flag, $ccn) = @_;
    my $gen = ($flag and $flag eq '-g');
    $ccn = $flag if not $gen;
    return usage($cmd) if not defined $ccn;
    my $ch = ($cmd eq 'luhn') ? luhn($ccn, $gen) : verhoeff($ccn, $gen);
    if (not defined $ch) {
        print "INVALID DIGIT\n";
        return 0;
    } elsif ($gen) {
        print "$ccn$ch\n";
    } elsif ($ch == 0) {
        print "ok\n";
    } else {
        print "INVALID CHECK\n";
        return 0;
    }
    return 1;
}

# -----------------------------------------------------------------
sub cmd_option {
    my $cmd = shift @_;
    if (not @_) { # print all options
        foreach my $var (sort keys %all_options) {
            print_option($var);
        }
        return 1;
    }
    foreach my $var (@_) {
        # var may be 'name', '!name', '+name', 'name=value'.
        my $set = undef;
        if (substr($var,0,1) eq '-') { $var = substr($var,1); } # ignore leading dash
        if ($var =~ /^ ([_!+]) (.*) \s*$/x) { # _name or !name or +name
            $var = $2;
            $set = ($1 eq '+') ? 1 : 0;
            if ($1 eq '_') {
                print_option($var);
                return 1;
            }
        } elsif ($var =~ /^ ([^=]+) = "([^"]*)" \s*$ /x) { # name="value"
            $var = $1;
            $set = $2;
        } elsif ($var =~ /^ ([^=]+) = (.*) \s*$ /x) { # name=value
            $var = $1;
            $set = $2;
        }
        if (defined $set and defined $set_alias{lc($set)}) {
            $set = $set_alias{lc($set)};
        }
        my $option = $all_options{$var};
        if (not $option) {
            print "ERROR: invalid option $var\n";
            return 0;
        }
        my ($type, $desc, $optfunc) = @$option;
        if ($type ne 'b' and not defined $set) {
            print "ERROR: missing = after option $var\n";
            return 0;
        }
        my $value = (defined $set) ? $set : $opt{$var} ? 0 : 1;
        if ($type eq 'i' and $value !~ /^-?\d+$/ and $value !~ /^0x[0-9a-f]+$/i) {
            print "ERROR: invalid number '$value' for option $var\n";
            return 0;
        }
        if ($type eq 'b' and $value ne '0' and $value ne '1') {
            print "ERROR: invalid boolean '$value' for option $var (use 0,1 or on,off)\n";
            return 0;
        }
        if ($optfunc and not &$optfunc($value)) { # call option handler, if any
            return 0;
        }
        $opt{$var} = $value;
        print_option($var);
    }
    return 1;
}

# -----------------------------------------------------------------
sub opt_rng {
    my ($value) = @_;
    if (not set_rng($value, $opt{seed})) {
        return 0;
    }
    return 1;
}

# -----------------------------------------------------------------
sub opt_seed {
    my ($value) = @_;
    if (not set_rng($opt{rng}, $value)) {
        return 0;
    }
    return 1;
}

# -----------------------------------------------------------------
sub print_option($) {
    my ($var) = @_;
    my $option = $all_options{$var};
    return if not $option;
    my ($type, $desc) = @$option;
    print "$var = ";
    if ($type eq 'b') {
        print ($opt{$var} ? 'ON' : 'off');
    } elsif ($type eq 's') {
        print '"', $opt{$var}, '"';
    } else {
        print $opt{$var};
    }
    print "\n";
}


# -----------------------------------------------------------------
# ---- El Gamal
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# p,g,y public
# x private
sub eg_gen($) {
    my ($bits) = @_;
    my $p = find_prime($bits); # shared
    my $g = random(2, $p-1); # shared
    my $x = random(2, $p-1); # private
    my $y = pow_mod($g, $x, $p); # public
    return { 'p' => $p, 'g' => $g, 'x' => $x, 'y' => $y };
}

# -----------------------------------------------------------------
sub eg_sign($$$$) {
    my ($p,$g,$x,$msg) = @_;
    return undef if msg_too_large($msg, $p);
    my $k = eg_k($p);
    my $ki = inv($k, $p-1);
    my $r = pow_mod($g, $k, $p);
    my $s = xmod(($msg - $x * $r) * $ki, $p-1);
    return { 'r' => $r, 's' => $s };
}

# -----------------------------------------------------------------
sub eg_verify($$$$$$) {
    my ($p,$g,$y,$r,$s,$msg) = @_;
    return 0 if msg_too_large($msg, $p);
    my $c1 = mul_mod(pow_mod($y, $r, $p), pow_mod($r, $s, $p), $p);
    my $c2 = pow_mod($g, $msg, $p);
    return ($c1 == $c2);
}

# -----------------------------------------------------------------
sub eg_encrypt($$$$) {
    my ($p,$g,$y,$msg) = @_;
    return undef if msg_too_large($msg, $p);
    my $k = eg_k($p);
    my $r = pow_mod($g, $k, $p);
    my $s = mul_mod(pow_mod($y, $k, $p), $msg, $p);
    return { 'r' => $r, 's' => $s };
} 

# -----------------------------------------------------------------
sub eg_decrypt($$$$$) {
    my ($p,$g,$x,$r,$s) = @_;
    return undef if msg_too_large($r, $p) or msg_too_large($s, $p);
    my $h = $opt{'eg-slow'} ?
        inv(pow_mod($r, $x, $p), $p) :
        pow_mod($r, $p-1-$x, $p); # shortcut by Lagrange's Theorem
    return undef if not defined $h;
    return mul_mod($s, $h, $p);
}

# -----------------------------------------------------------------
sub eg_k($) {
    my ($p) = @_;
    for (;;) {
        my $k = random(2, $p-2);
        return $k if gcd($k, $p-1) == 1;
    }
}


# -----------------------------------------------------------------
# ---- RSA
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub rsa_gen($) {
    my ($bits) = @_;
    my $bits2 = rshift($bits, 1); # bits/2 for p, and bits/2 for q
    my $p = find_prime($bits2);
    my $q = find_prime($bits - $bits2);
    my $n = $p * $q; # public
    my $n1 = $opt{'rsa-orig'} ? ($p-1) * ($q-1) : lcm($p-1, $q-1);
    my $e = rsa_exponent($bits, $n1); # public
    my $d = inv($e, $n1); # private
    if ($e >= $n or $d >= $n) {
        print "keys don't fit in $bits bits; try --rsa-randexp?\n";
        return undef;
    }
    return { 'e' => $e, 'd' => $d, 'n' => $n };
}

# -----------------------------------------------------------------
sub rsa_exponent($$) {
    my ($bits, $n1) = @_;
    my $e = $opt{'rsa-randexp'} ? 0 : 65537;
    for (;;) {
        $e = random(2, $n1-1) | 1 if not $e;
        return $e if gcd($e,$n1) == 1;
        $e = 0; # try again
    } 
}

# -----------------------------------------------------------------
sub rsa_crypt($$$) {
    my ($msg, $e, $n) = @_;
    return undef if msg_too_large($msg, $n);
    return pow_mod($msg, $e, $n);
}

# -----------------------------------------------------------------
# --- Rabin Encryption
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub rabin_gen($) {
    my ($bits, $sign_nonce_bits) = @_;
    if (not $bits) {
        print "invalid bit length \"$bits\"\n";
        return undef;
    }
    $sign_nonce_bits = 0 if not $sign_nonce_bits;
    my $bits2 = rshift($bits, 1);
    my $p = find_blum_prime($bits-$bits2);
    my $q = find_blum_prime($bits2);
    if ($p < $q) { ($p,$q) = ($q,$p); }
    # Note n may be $bits-1 bits due to multiply.
    return { 'p' => $p, 'q' => $q, 'n' => $p*$q, 'bits' => $bits, 'sign_nonce_bits' => $sign_nonce_bits };
}

# -----------------------------------------------------------------
sub rabin_encrypt($$) {
    my ($n, $msg) = @_;
    return undef if msg_too_large($msg, $n);
    return mul_mod($msg, $msg, $n);
}

# -----------------------------------------------------------------
# Returns four possible decryptions.
sub rabin_decrypt($$$$) {
    my ($p, $q, $n, $enc) = @_;
    return () if msg_too_large($enc, $n);
    # Find modular square root of enc, mod p and mod q.
    # That is, (mp*mp % p) = enc, and (mq*mq % q) = enc.
    my $mp = pow_mod($enc, rshift($p+1,2), $p);
    my $mq = pow_mod($enc, rshift($q+1,2), $q);
    my ($a, $b) = euclid_pair($p, $q);
    # Use Chinese remainder theorem to find 4 candidates r1..r4.
    my $t1 = xmod($a * $p * $mq, $n);
    my $t2 = xmod($b * $q * $mp, $n);
    my $r1 = xmod($t1 + $t2, $n);
    my $r2 = xmod($t1 - $t2, $n);
    my $r3 = $n - $r1;
    my $r4 = $n - $r2;
    return ($r1, $r2, $r3, $r4);
}

# -----------------------------------------------------------------
sub rabin_sign($$$) {
    my ($p, $q, $n, $bits, $sign_nonce_bits, $msg) = @_;
    if (not $sign_nonce_bits) {
        print "must invoke rabin-gen with sign_nonce_bits>0 before invoking rabin-sign\n";
        return undef;
    }
    for (my $tries = 0;; ++$tries) { # expected number of tries is 4
        my $umax = lshift(1, $sign_nonce_bits);
        my $u = random(rshift($umax,1), $umax-1);
        my $c = rabin_msg($msg, $u, $bits);
        return undef if not defined $c;
        my @xs = rabin_decrypt($p, $q, $n, $c);
        next if not @xs;
        my $x = shift @xs;
        return { 'u'=>$u, 'x'=>$x } if rabin_encrypt($n, $x) == $c;
    }
}

# -----------------------------------------------------------------
sub rabin_verify($$$$$) {
    my ($n, $bits, $u, $x, $msg) = @_;
    my $c = rabin_msg($msg, $u, $bits);
    return undef if not defined $c;
    return rabin_encrypt($n, $x) == $c;
}

# -----------------------------------------------------------------
sub rabin_msg($$$) {
    my ($msg, $u, $bits) = @_;
    if ($bits < 4) {
        print "bits ($bits) must be >= 4\n";
        return undef;
    }
    # Must be less than n, which may be bits-1, so make this bits-2.
    return int_from_bytes($msg.'+'.$u, $bits-2);
}

# -----------------------------------------------------------------
# ---- Schnorr
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub schnorr_gen($$) {
    my ($bits, $qbits) = @_;
    # p,q,a are parameters that can be shared among different key pairs.
    my ($p,$q,$r) = find_pq_prime($bits, $qbits);
    my $a = pow_mod(3, $r, $p); # a has order q
    die if pow_mod($a, $q, $p) != 1;

    my $s = random(2, $q-1); # private key
    my $v = pow_mod(inv($a, $p), $s, $p); # public key
    return { 'p' => $p, 'q' => $q, 'a' => $a, 'qbits' => $qbits, 's' => $s, 'v' => $v };
}

sub schnorr_sign($$$$$$) {
    my ($p, $q, $a, $qbits, $s, $msg) = @_;
    my $r = random(1, $q-1);
    my $x = pow_mod($a, $r, $p);
    my $e = int_from_bytes($msg.'+'.$x, $qbits) % $q;
    my $y = ($r + $s*$e) % $q;
    return { 'e' => $e, 'y' => $y };
}

sub schnorr_verify($$$$$$$$) {
    my ($p, $q, $a, $qbits, $v, $e, $y, $msg) = @_;
    my $x = mul_mod(pow_mod($a, $y, $p), pow_mod($v, $e, $p), $p);
    my $e2 = int_from_bytes($msg.'+'.$x, $qbits) % $q;
    return $e2 == $e;
}

# -----------------------------------------------------------------
# ---- Blum-Goldwasser
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub bg_gen($) {
    my ($bits) = @_;
    return rabin_gen($bits);
}

# -----------------------------------------------------------------
sub bg_encrypt($$) {
    my ($n,$msg) = @_;
    # h = bits per block
    my $h = number_bits(number_bits($n));
    # t = blocks in msg
    my $t = int((number_bits($msg) + $h-1) / $h);
    # x = random quadratic residue mod n
    my $r = random(1, $n);
    my $x = mul_mod($r, $r, $n);
    ($msg, $x) = bg_crypt($msg, $n, $h, $t, $x);
    return { 'h' => $h, 't' => $t, 'xt' => mul_mod($x, $x, $n), 'c' => $msg };
}

# -----------------------------------------------------------------
sub bg_decrypt($$$$$$$) {
    my ($p,$q,$n,$h,$t,$xt,$enc) = @_;
    my $dp = pow_mod(rshift($p+1,2), $t+1, $p-1);
    my $dq = pow_mod(rshift($q+1,2), $t+1, $q-1);
    my $up = pow_mod($xt, $dp, $p);
    my $uq = pow_mod($xt, $dq, $q);
    my ($rp, $rq) = euclid_pair($p, $q);
    my $x = xmod($uq*$rp*$p - $up*$rq*$q, $n);
    my ($msg) = bg_crypt($enc, $n, $h, $t, $x);
    return $msg;
}

# -----------------------------------------------------------------
sub bg_crypt($$$$$) {
    my ($msg, $n, $h, $t, $x) = @_;
    my $hmask = rmask($h);
    my $shmask = $hmask;
    my $enc = 0;
    for (my $i = 0; $i < $t; ++$i) {
        $x = mul_mod($x, $x, $n); # get keystream bits from BBS
        $enc |= ($msg & $shmask) ^ lshift($x & $hmask, $i*$h);
        $shmask = lshift($shmask, $h);
    }
    return ($enc, $x);
}

# -----------------------------------------------------------------
# ---- Cramer-Shoup
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub cs_gen($$) {
    my ($bits, $qbits) = @_;
    my ($p,$q) = find_pq_prime($bits, $qbits, 2, 2);
    my $g1 = random(2, $p);
    my $g2 = random(2, $p);
    my $x1 = random(2, $q);
    my $x2 = random(2, $q);
    my $y1 = random(2, $q);
    my $y2 = random(2, $q);
    my $z  = random(2, $q);
    my $c = mul_mod(pow_mod($g1, $x1, $p), pow_mod($g2, $x2, $p), $p);
    my $d = mul_mod(pow_mod($g1, $y1, $p), pow_mod($g2, $y2, $p), $p);
    my $h = pow_mod($g1, $z, $p);
    return { 'p'=>$p, 'q'=>$q, 'g1'=>$g1, 'g2'=>$g2, 'c'=>$c, 'd'=>$d, 'h'=>$h,  # public
             'x1'=>$x1, 'x2'=>$x2, 'y1'=>$y1, 'y2'=>$y2, 'z'=>$z };     # private
}

# -----------------------------------------------------------------
sub cs_encrypt($$$$$$$$) {
    my ($p, $q, $qbits, $g1, $g2, $c, $d, $h, $msg) = @_;
    my $r = random(1, $q-1);
    my $u1 = pow_mod($g1, $r, $p);
    my $u2 = pow_mod($g2, $r, $p);
    my $e = mul_mod($msg, pow_mod($h, $r, $p), $p);
    my $a = int_from_bytes($u1.'+'.$u2.'+'.$e, $qbits);
    my $v = mul_mod(pow_mod($c, $r, $p), pow_mod($d, $r*$a, $p), $p);
    return { 'u1'=>$u1, 'u2'=>$u2, 'e'=>$e, 'v'=>$v };
}

# -----------------------------------------------------------------
sub cs_decrypt($$$$$$$$$$) {
    my ($p, $q, $qbits, $x1, $x2, $y1, $y2, $z, $u1, $u2, $e, $v) = @_;
    my $a = int_from_bytes($u1.'+'.$u2.'+'.$e, $qbits);
    my $vc = mul_mod(pow_mod($u1, $x1+($y1*$a), $p), pow_mod($u2, $x2+($y2*$a), $p), $p);
    return undef if $vc != $v;
    return mul_mod($e, inv(pow_mod($u1, $z, $p), $p), $p);
}

# -----------------------------------------------------------------
# ---- Solitaire
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub sol_crypt($$$) {
    my ($encrypt, $deck, $msg) = @_;
    my $res = '';
    sol_print_deck($deck) if $opt{verbose};
    for (my $i = 0; $i < length $msg; ++$i) {
        my $cval = sol_char_value(substr($msg, $i, 1));
        next if $cval < 1 or $cval > 26;
        my $k = 0;
        while (not $k) {
            $k = sol_keystream($deck);
            sol_print_deck($deck) if $opt{verbose};
        }
        print "keystream $k\n" if $opt{verbose};
        $k = -$k if not $encrypt;
        $cval = xmod($cval-1 + $k, 26) + 1;
        die if $cval < 1 or $cval > 26;
        $res .= sol_value_char($cval);
    }
    return $res;
}

# -----------------------------------------------------------------
# Schneier's "method 3" which derives a deck order from an alphabetic key.
sub sol_deck_from_key($) {
    my ($key) = @_;
    $key =~ s/[^a-z]//ig;
    my @deck = ( 1 .. $suit_cards+$jokers ); # start with deck in standard order
    for (my $i = 0; $i < length $key; ++$i) {
        my $ch = sol_char_value(substr($key, $i, 1));
        next if $ch < 1 or $ch > 26;
        sol_keystream(\@deck, $ch);
    }
    return \@deck;
}

# -----------------------------------------------------------------
sub sol_keystream($;$) {
    my ($deck, $keygen) = @_;
    return 0 if $keygen and ($keygen < 1 or $keygen > 26);
    sol_move($deck, $jokerA, +1);
    sol_move($deck, $jokerB, +2);
    sol_triple_cut($deck);
    sol_count_cut($deck, $$deck[$#$deck]);
    if ($keygen) {
        sol_count_cut($deck, $keygen);
        return 0;
    }
    my $index = min($$deck[0], sol_cards()-1);
    my $value = $$deck[$index];
    return 0 if $value > $suit_cards; # ignore joker
    return $value;
}

# -----------------------------------------------------------------
# Move a card a fixed number of positions forward in the deck.
sub sol_move($$$) {
    my ($deck, $card, $moves) = @_;
    my $index = first_index { $_ == $card } @$deck;
    die if $index < 0; # card not in deck?
    if ($index + $moves >= sol_cards()) { # wrap to start of deck
        my @card = splice $deck, $index, 1;
        splice $deck, $index + $moves - sol_cards() + 1, 0, @card;
    } else {
        splice $deck, $index, $moves+1, @$deck[$index+1 .. $index+$moves], $$deck[$index];
    }
}

# -----------------------------------------------------------------
sub sol_triple_cut($) {
    my ($deck) = @_;
    my $j1 = first_index { $_ == $jokerA } @$deck;
    my $j2 = first_index { $_ == $jokerB } @$deck;
    ($j1,$j2) = ($j2,$j1) if $j1 > $j2;
    my @tail = splice $deck, $j2+1; # remove tail
    my @head = splice $deck, 0, $j1, @tail; # replace head with tail
    push $deck, @head; # append head
}

# -----------------------------------------------------------------
sub sol_count_cut($$) {
    my ($deck, $count) = @_;
    my @cards = splice $deck, 0, min($count, sol_cards()-1);
    splice $deck, -1, 0, @cards;
}

# -----------------------------------------------------------------
sub sol_char_value($) {
    my ($ch) = @_;
    return ord(uc($ch)) - ord('A') + 1;
}

# -----------------------------------------------------------------
sub sol_value_char($) {
    my ($val) = @_;
    return chr($val-1 + ord('A'));
}

# -----------------------------------------------------------------
sub sol_cards() {
    return $suit_cards + $jokers;
}

# -----------------------------------------------------------------
sub sol_print_deck($) {
    my ($deck) = @_;
    my $print_cards = $opt{cards};
    for (my $i = 0; $i < @$deck; ++$i) {
        my $card = $$deck[$i];
        my $pr_card = $print_cards ? sol_playing_card($card) : $card;
        print $pr_card, ' ';
        print "\n" if $print_cards and $i == (sol_cards() / 2) - 1;
    }
    print "\n";
}

# -----------------------------------------------------------------
sub sol_playing_card($) {
    my ($n) = @_;
    die if $n > sol_cards();
    my @playing_card = qw( ZZ
        Ac 2c 3c 4c 5c 6c 7c 8c 9c Tc Jc Qc Kc
        Ad 2d 3d 4d 5d 6d 7d 8d 9d Td Jd Qd Kd
        Ah 2h 3h 4h 5h 6h 7h 8h 9h Th Jh Qh Kh
        As 2s 3s 4s 5s 6s 7s 8s 9s Ts Js Qs Ks
        =A =B
    );
    return $playing_card[$n];
}

# -----------------------------------------------------------------
# Diffie-Hellman key exchange
sub dh_key_exchange($) {
    my ($bits) = @_;
    my $base = 3;
    my $mod = find_prime($bits);
    my $sa = random(rshift($mod,1), $mod-1);
    my $sb = random(rshift($mod,1), $mod-1);
    my $pa = pow_mod($base, $sa, $mod);
    my $pb = pow_mod($base, $sb, $mod);
    my $ab = pow_mod($pb, $sa, $mod);
    my $ba = pow_mod($pa, $sb, $mod);

    print "A and B agree on base $base and modulus $mod\n";
    print "A generates secret $sa\n";
    print "B generates secret $sb\n";
    print "A calculates $base^$sa mod $mod = $pa and publishes it\n";
    print "B calculates $base^$sb mod $mod = $pb and publishes it\n";
    print "A calculates shared $pb^$sa mod $mod = $ab\n";
    print "B calculates shared $pa^$sb mod $mod = $ba\n";
}

# -----------------------------------------------------------------
# Standard (Luhn) credit card check digit.
sub luhn($;$) {
    my ($ccn, $gen) = @_;
    my $total = 0;
    $ccn .= '0' if $gen;
    for (my $i = 0; $i < length($ccn); ++$i) {
        my $digit = ord(substr($ccn, length($ccn)-$i-1, 1)) - ord('0');
        return undef if $digit < 0 or $digit >= 10;
        $digit *= 2 if $i & 1;
        $digit -= 9 if $digit > 9;
        $total += $digit;
    }
    $total %= 10;
    $total = 10 - $total if $gen and $total > 0;
    return $total;
}

# -----------------------------------------------------------------
# Verhoeff credit card check digit.
sub verhoeff($;$) {
    my ($ccn, $gen) = @_;
    my @d = (
        [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
        [ 1, 2, 3, 4, 0, 6, 7, 8, 9, 5 ],
        [ 2, 3, 4, 0, 1, 7, 8, 9, 5, 6 ],
        [ 3, 4, 0, 1, 2, 8, 9, 5, 6, 7 ],
        [ 4, 0, 1, 2, 3, 9, 5, 6, 7, 8 ],
        [ 5, 9, 8, 7, 6, 0, 4, 3, 2, 1 ],
        [ 6, 5, 9, 8, 7, 1, 0, 4, 3, 2 ],
        [ 7, 6, 5, 9, 8, 2, 1, 0, 4, 3 ],
        [ 8, 7, 6, 5, 9, 3, 2, 1, 0, 4 ],
        [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ],
    );
    my @p = (
        [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
        [ 1, 5, 7, 6, 2, 8, 3, 0, 9, 4 ],
        [ 5, 8, 0, 3, 7, 9, 6, 1, 4, 2 ],
        [ 8, 9, 1, 6, 0, 4, 3, 5, 2, 7 ],
        [ 9, 4, 5, 3, 1, 2, 6, 8, 7, 0 ],
        [ 4, 2, 8, 6, 5, 7, 3, 9, 0, 1 ],
        [ 2, 7, 9, 3, 8, 0, 6, 4, 1, 5 ],
        [ 7, 0, 4, 6, 9, 1, 3, 2, 5, 8 ],
    );
    my @inv = ( 0, 4, 3, 2, 1, 5, 6, 7, 8, 9 );

    $ccn .= '0' if $gen;
    my $total = 0;
    for (my $i = 0; $i < length($ccn); ++$i) {
        my $digit = ord(substr($ccn, length($ccn)-$i-1, 1)) - ord('0');
        return undef if $digit < 0 or $digit > 9;
        my $p = ${$p[$i % 8]}[$digit];
        $total = ${$d[$total]}[$p];
    }
    $total = $inv[$total] if $gen;
    return $total;
}

# -----------------------------------------------------------------
# ---- Sort
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Insertion sort with linear search.
sub insertl_sort(@) {
    my @sorted;
    for (;;) {
        my $item = shift @_;
        last if not defined $item;
        my $ins = 0;
        while ($ins < @sorted and $item > $sorted[$ins]) {
            ++$ins;
        }
        splice @sorted, $ins, 0, $item;
    }
    return @sorted;
}

# -----------------------------------------------------------------
# Insertion sort with binary search.
sub insertb_sort(@) {
    my @sorted;
    for (;;) {
        my $item = shift @_;
        last if not defined $item;
        my ($lo,$hi) = (0,0);
        for (($lo,$hi) = (0, scalar @sorted); $lo < $hi;) {
            my $mid = rshift($lo + $hi, 1);
            if ($sorted[$mid] < $item) {
                $lo = $mid + 1;
            } else {
                $hi = $mid;
            }
        }
        splice @sorted, $lo, 0, $item;
    }
    return @sorted;
}

# -----------------------------------------------------------------
sub merge_sort(@) {
    my $len = scalar @_;
    return @_ if $len < 2;
    $len = int($len/2);
    my @sub1 = merge_sort(splice(@_, 0, $len));
    my @sub2 = merge_sort(@_);
    my @sorted;
    while (@sub1 > 0 and @sub2 > 0) {
        if ($sub1[0] < $sub2[0]) {
            push @sorted, shift @sub1;
        } else {
            push @sorted, shift @sub2;
        }
    }
    push @sorted, @sub1;
    push @sorted, @sub2;
    return @sorted;
}

# -----------------------------------------------------------------
sub quick_sort(@) {
    quick_sort_range(\@_, 0, @_-1, $opt{'qs-pivot'});
    return @_;
}

sub quick_sort_range($$$) {
    my ($arr, $lo, $hi, $pivot_type) = @_;
    return if $lo >= $hi; # 0 or 1 elements are already sorted
    my $pivot;
    if ($pivot_type == 1) {
        $pivot = $$arr[$lo];
    } elsif ($pivot_type == 2) {
        $pivot = $$arr[$hi];
    } elsif ($pivot_type == 3) {
        $pivot = $$arr[int(($hi+$lo)/2)];
    } elsif ($pivot_type == 4) {
        my ($p1,$p2,$p3) = sort3($$arr[$lo], $$arr[$hi], $$arr[int(($hi+$lo)/2)]);
        $pivot = $p2;
    } else { die; }

    my $plo = $lo-1;
    my $phi = $hi+1;
    for (;;) {
        do { ++$plo; } while $$arr[$plo] < $pivot;
        do { --$phi; } while $$arr[$phi] > $pivot;
        last if $plo >= $phi;
        ($$arr[$plo], $$arr[$phi]) = ($$arr[$phi], $$arr[$plo]);
    }
die unless $phi < $hi; # qs-pivot=hi trips this
    quick_sort_range($arr, $lo, $phi, $pivot_type);
    quick_sort_range($arr, $phi+1, $hi, $pivot_type);
}

# -----------------------------------------------------------------
sub sort3 {
    my ($a,$b,$c) = @_;
    if ($a < $b) {
        return ($a,$b,$c) if $b < $c;
        return ($a,$c,$b) if $a < $c;
        return ($c,$a,$b);
    } else {
        return ($b,$a,$c) if $a < $c;
        return ($b,$c,$a) if $b < $c;
        return ($c,$b,$a);
    }
}

# -----------------------------------------------------------------
# Fisher-Yates shuffle.
sub shuffle($) {
    my ($list) = @_;
    for (my $i = @$list-1; $i > 0; --$i) {
        my $j = random(0,$i);
        ($$list[$i], $$list[$j]) = ($$list[$j], $$list[$i]);
    }
}

# -----------------------------------------------------------------
# ---- Encrypted Key Exchange
# -----------------------------------------------------------------

#
#   Es / Ds = symmetric encrypt / decrypt
#   Ea / Da = asymmetric encrypt / decrypt
#   pwd = shared password
#
#   A generates random Kpub and Kpriv keys
#   A publishes A1 = Es(pwd, Kpub)
#
#   B calculates Kpub' = Ds(pwd, A1)
#   B generates random Kb
#   B publishes B1 = Es(pwd, Ea(Kpub', Kb))
#
#   A calculates Kb' = Da(Kpriv, Ds(pwd, B1))
#   A generates random Ra
#   A publishes A2 = Es(Kb', Ra)
#
#   B calculates Ra' = Ds(Kb, A2)
#   B generates random Rb
#   B publishes B2 = Es(Kb, Ra'.Rb)
#
#   A calculates Rc = Ds(Kb', B2)
#   A verifies substr(Rc,0,len(Ra)) eq Ra
#   A calculates Rb' = substr(Rc,len(Ra))
#   A publishes A3 = Es(Kb', Rb')
#
#   B calculates Rb'' = Ds(Kb, A3)
#   B verifies Rb'' eq Rb
#
#


# -----------------------------------------------------------------
# ---- Random numbers
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Return random integer between $min and $max inclusive.
# Get random bytes and do arithmetic.
sub random($$) {
    my ($min, $max) = @_;
    return $min if $min >= $max;
    my $m = $max - $min + 1;
    my $bytes = rshift(number_bits($m)+7, 3);
    my $rand = $rng->{get}($rng, $bytes);
    return undef if not defined $rand;
    my $n = 0;
    for (my $i = 0; $i < $bytes; ++$i) {
        $n = lshift($n,8) + ord(substr($rand,$i,1));
    }
    # FIXME: mod here is biased.
    $n = ($n % $m);
    return $min + $n;
}

# -----------------------------------------------------------------
sub get_bytes {
    my ($obj, $bytes) = @_;
    my $data = '';
    while (length($data) < $bytes) {
        my $byte = $obj->{get_byte}($obj);
        return undef if not defined $byte;
        $data .= chr($byte);
    }
    return $data;
}

# -----------------------------------------------------------------
# Standard RNG. Uses rand().
sub std_rng_init($$) {
    my ($bits, $seed) = @_;
    if ($seed and length($seed) > 0) {
        srand(int_from_bytes($seed, $bits));
    }
    return { 'get' => \&get_bytes, 'get_byte' => \&std_rng_get_byte };
}

sub std_rng_get_byte($) {
    my ($std) = @_;
    return (int(rand(0x1000000)) >> 8) & 0xff;
}

# -----------------------------------------------------------------
# Simple RNG.
sub sim_rng_init($$) {
    my ($bits, $seed) = @_;
    my $iseed = ($seed and length($seed) > 0) ? int_from_bytes($seed, 32) : 0;
    return { 'get' => \&get_bytes, 'get_byte' => \&sim_rng_get_byte, 'seed' => $iseed };
}

sub sim_rng_get_byte($) {
    my ($sim) = @_;
    $sim->{seed} = (($sim->{seed} * 1664525) + 1013904223) & 0xFFFFFFFF;
    return rshift($sim->{seed}, 24);
}

# -----------------------------------------------------------------
# Secure RNG. Uses Math::Random::Secure.
sub sec_rng_init($$) {
    my ($bits, $seed) = @_;
    if (not eval "require Math::Random::Secure") {
        print "Math::Random::Secure module not found\n";
        return undef;
    }
    if ($seed and length($seed) > 0) {
        Math::Random::Secure::srand($seed);
    }
    return { 'get' => \&get_bytes, 'get_byte' => \&sec_rng_get_byte };
}

sub sec_rng_get_byte($) {
    my ($sec) = @_;
    return Math::Random::Secure::irand() & 0xff;
}

# -----------------------------------------------------------------
# Blum-Blum-Shub RNG.
sub bbs_rng_init($$) {
    my ($bits, $seed) = @_;
    $seed = 1 if not $seed;
    # BBS needs another RNG for find_prime ???
    $rng = std_rng_init($bits, $seed) if not $rng;
    my $rabin = rabin_gen($bits);
    return undef if not $rabin;
    my $rn = $rabin->{n};
    my $x = int_from_bytes($seed, $bits) % $rn;
    while (gcd($x, $rn) != 1) {
        return undef if not $x;
        --$x;
    }
    return { 'get' => \&get_bytes, 'get_byte' => \&bbs_rng_get_byte, 'n' => $rn, 'x' => $x };
}

sub bbs_rng_get_byte($) {
    my ($bbs) = @_;
    my $n = $bbs->{n};
    my $x = $bbs->{x};
    my $byte = 0;
    for (my $i = 0; $i < 8; ++$i) {
        $x = mul_mod($x, $x, $n);
        $byte = lshift($byte,1) | ($x & 1);
    }
    $bbs->{x} = $x;
    return $byte;
}

# -----------------------------------------------------------------
# Mersenne twister.
sub twi_rng_init($$) {
    my ($bits, $seed) = @_;
    my $bmask = rmask($bits);
    my $n = 312;
    my $f = 6364136223846793005;
    my @mt;
    push @mt, int_from_bytes($seed, $bits);
    for (my $i = 1; $i < $n; ++$i) {
        push @mt, ($f * ($mt[$i-1] ^ ($mt[$i-1] >> ($bits-2))) + $i) & $bmask;
    }
    return { 'get' => \&twi_rng_get_bytes,
        'bits' => $bits,
        'mt' => \@mt,
        'index' => $n, 
        'a' => 0xB5026F5AA96619E9,
        'b' => 0x71D67FFFEDA60000,
        'c' => 0xFFF7EEE000000000,
        'd' => 0x5555555555555555,
        'l' => 43,
        'm' => 156,
        'n' => $n,
        'r' => 31,
        's' => 17,
        't' => 37,
        'u' => 29,
    };
}

sub twi_rng_get_bytes($$) {
    my ($twi, $bytes) = @_;
    my $n = $twi->{n};
    my $mt = $twi->{mt};
    my $bits = $twi->{bits};
    my $ibytes = int($bits / 8);
    my $data = '';
    while (length($data) < $bytes) {
        if ($twi->{index} >= $n) {
            my $lower_mask = rmask($twi->{r});
            my $upper_mask = lshift(rmask($bits - $twi->{r}), $twi->{r});
            for (my $i = 0; $i < $n; ++$i) {
                my $j = $i+1;
                $j = 0 if $j == $n; # wrap
                die if $j >= $n;
                my $x = ($$mt[$i] & $upper_mask) + ($$mt[$j] & $lower_mask);
                my $xa = rshift($x,1);
                $xa ^= $twi->{a} if $x & 1;
                $$mt[$i] = $$mt[($i + $twi->{m}) % $n] ^ $xa;
            }
            $twi->{index} = 0;
        }
        my $y = $$mt[$twi->{index}++];
        $y ^= rshift($y, $twi->{u}) & $twi->{d};
        $y ^= lshift($y, $twi->{s}) & $twi->{b};
        $y ^= lshift($y, $twi->{t}) & $twi->{c};
        $y ^= rshift($y, $twi->{l});
        # y is the RNG result. Extract ibytes bytes from it.
        for (my $i = 0; $i < $ibytes; ++$i) {
            last if length($data) >= $bytes;
            $data .= chr($y & 0xFF);
            $y = rshift($y, 8);
        }
    }
    return $data;
}


# -----------------------------------------------------------------
# ---- Math
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Return ($base ** $exp) % $mod, in O(lg($exp)).
sub pow_mod($$$) {
    my ($base, $exp, $mod) = @_;
    my $res = 1;
    for (; $exp != 0; $exp = rshift($exp,1)) {
        $res = mul_mod($res, $base, $mod) if ($exp & 1);
        $base = mul_mod($base, $base, $mod);
    }
    return $res;
}

# -----------------------------------------------------------------
sub mul_mod($$$) {
    my ($a, $b, $mod) = @_;
    return ($a * $b) % $mod;
}

# -----------------------------------------------------------------
# Miller-Rabin primality test.
sub is_prime($) {
    my ($num) = @_;

    # For efficiency, try some small prime factors first.
    return 0 if $num <= 1;
    return ($num == 2) if is_even($num);
    foreach my $p (qw(3 5 7 11 13 17 19 23 27)) {
        return 1 if $num == $p;
        return 0 if ($num % $p) == 0;
    }

    # Find s,t such that (t * 2**s == num-1), t odd.
    # ie. s is number of trailing zeros in binary representation of num-1,
    # and t is num-1 with those zeros right-shifted away.
    my $s = 0;
    my $t = $num-1;
    while (is_even($t)) {
        ++$s;
        $t = rshift($t,1);
    }

    # Repeat Miller-Rabin loops times, each with a random witness.
    my $loops = $opt{loops};
    while ($loops-- > 0) {
        my $a = random(2, $num-2); # witness
        my $x = pow_mod($a, $t, $num);
        return 0 if pow_mod($x, $num-1, $num) != 1;
        # Look for fake sqrt of 1: x^2 = 1 but x != +-1.
        for (my $i = 0; $i < $s; ++$i) {
            my $x2 = mul_mod($x, $x, $num);
            return 0 if $x2 == 1 and $x != 1 and $x != $num-1;
            $x = $x2;
        }
    }
    return 1; # probably prime
}

# -----------------------------------------------------------------
# Find a random prime number, a specified number of bits in length.
sub find_prime($) {
    my ($bits) = @_;
    my $m = lshift(1,$bits);
    my $n = random(rshift($m,1), $m-1) | 1;
    for (;; $n -= 2) { last if is_prime($n); }
    return $n;
}

# -----------------------------------------------------------------
sub find_blum_prime($) {
    my ($bits) = @_;
    for (;;) {
        my $p = find_prime($bits);
        return $p if ($p % 4) == 3;
    }
}

# -----------------------------------------------------------------
# Return (p,q,r) such that p is prime, q is prime and p = qr+1.
sub find_pq_prime($$;$;$) {
    my ($bits, $qbits, $rmax, $rmin) = @_;
    $rmax = rmask($bits-$qbits-1) if not defined $rmax;
    $rmin = rshift($rmax,1) if not defined $rmin;
    for (;;) {
        my $q = find_prime($qbits); # pick the large factor first
        my $r = random($rmin, $rmax);
        my $p = ($q*$r)+1;
        return ($p,$q,$r) if is_prime($p);
    }
}

# -----------------------------------------------------------------
# Extended Euclidean algorithm.
# euclid(u,v) returns (w,x,a,b,g,k) such that
#   w = u>>k, x = v>>k, w,x not both even
#   g = gcd(u,v) = a*w - b*x = (a*u - b*v) >>k
sub euclid($$) {
    my ($u, $v) = @_;
    if ($u < $v) { ($u,$v) = ($v,$u); }
    my $k = 0;
    for (; is_even($u) and is_even($v); ++$k) {
        $u = rshift($u,1); $v = rshift($v,1);
    }
    my ($u1, $u2, $u3, $v1, $v2, $v3) = (1, 0, $u, $v, $u-1, $v);
    do {
        do {
            if (is_even($u3)) {
                if (not is_even($u1) or not is_even($u2)) {
                    $u1 += $v; $u2 += $u;
                }
                $u1 = rshift($u1,1); $u2 = rshift($u2,1); $u3 = rshift($u3,1);
            }
            if (is_even($v3) or $u3 < $v3) { # swap u* with v*
                ($u1,$u2,$u3,$v1,$v2,$v3) = ($v1,$v2,$v3,$u1,$u2,$u3);
            }
        } while (is_even($u3));
        while ($u1 < $v1 or $u2 < $v2) {
            $u1 += $v; $u2 += $u;
        }
        $u1 -= $v1; $u2 -= $v2; $u3 -= $v3;
    } while ($v3 > 0); 
    while ($u1 >= $v and $u2 >= $u) {
        $u1 -= $v; $u2 -= $u;
    }
    $u1 = lshift($u1,$k); $u2 = lshift($u2,$k); $u3 = lshift($u3,$k);
    return ($u, $v, $u1, $u2, $u3, $k);
}

# -----------------------------------------------------------------
# Return (u^-1 % v); that is, x such that u*x % v == 1.
sub inv($$) {
    my ($u, $v) = @_;
    my ($u2,$v2,$a,$b,$gcd) = euclid($u, $v);
    return undef if $gcd != 1; # no inverse
    return $u2 - $b;
}

# -----------------------------------------------------------------
# Return greatest common divisor of u and v.
sub gcd($$) {
    my ($u, $v) = @_;
    my ($u2,$v2,$a,$b,$gcd) = euclid($u, $v);
    return $gcd;
}

# -----------------------------------------------------------------
# Return least common multiple of u and v.
# lcm(u,v) = (u*v)/gcd(u,v)
sub lcm($$) {
    my ($u, $v) = @_;
    my $gcd = gcd($u, $v);
    return undef if not $gcd;
    my $r = $u * $v;
    $r->bdiv($gcd);
    return $r;
}

# -----------------------------------------------------------------
# Euler's criterion
sub is_quad_residue($$) {
    my ($a, $p) = @_;
    if (not is_prime($p)) {
        print "ERROR: $p is not prime, you dummy.\n";
        return undef;
    }
    my $r = pow_mod($a, rshift($p-1,1), $p);
    return ($r == 1);
}

# -----------------------------------------------------------------
sub is_even($) {
    my ($n) = @_;
    return ($n & 1) == 0;
}

# -----------------------------------------------------------------
sub lshift($$) {
    my ($n, $shift) = @_;
    $n = $n+0;
    $n->blsft($shift);
    return $n;
}

# -----------------------------------------------------------------
sub rshift($$) {
    my ($n, $shift) = @_;
    $n = $n+0;
    $n->brsft($shift);
    return $n;
}

# -----------------------------------------------------------------
sub rmask($) {
    my ($n) = @_;
    return (lshift(1, $n) - 1);
}

# -----------------------------------------------------------------
sub number_bits {
    my ($num) = @_;
    my $bits = 0;
    for (; $num > 0; $num = rshift($num,1)) {
        ++$bits;
    }
    return $bits;
}

# -----------------------------------------------------------------
# Make sure mod does the right thing with negative numbers.
sub xmod($$) {
    my ($n, $m) = @_;
    my $a = 0;
    $a = (int(-$n/$m)+2) * $m if $n < 0;
    return ($n + $a) % $m;
}



# -----------------------------------------------------------------
# ---- Misc
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub args(+@) {
    my $args = shift @_;
    my @rargs;
    push @rargs, shift @$args;
    foreach my $arg (@$args) {
        if ($arg eq '-') {
            foreach my $var (@_) {
                push @rargs, $$saved{$var};
            }
        ## } elsif ($arg =~ /^-([a-z]+)/) {
        ##     $flags .= $1;
        } else {
            my $val = i($arg);
            return undef if not defined $val;
            push @rargs, $val;
        }
    }
    return @rargs;
}

# -----------------------------------------------------------------
sub msg_too_large($$) {
    my ($msg, $n) = @_;
    return 0 if $msg < $n;
    print "ERROR: plaintext $msg must be less than $n\n";
    return 1;
}

# -----------------------------------------------------------------
sub int_from_bytes($$) {
    my ($data, $bits) = @_;
    die if not $bits;
    my $hash = Digest::SHA::sha256($data);
    my $hashx = 0; # Byte index in $hash
    my $bitx = 0; # Bit index (0-7) in $hashx byte
    my $num = 0;
    for (my $i = 0; $i < $bits; ++$i) {
        my $bit = (ord(substr($hash, $hashx, 1)) >> $bitx) & 1;
        $num |= lshift(1,$i) if $bit;
        if (++$bitx >= 8) {
            $bitx = 0;
            if (++$hashx >= length($hash)) {
                $hashx = 0;
                $hash = Digest::SHA::sha256($hash);
            }
        }
    }
    return $num;
}

# -----------------------------------------------------------------
# Return BigInt representation.
sub i($) {
    my ($s) = @_;
    return $1+0    if $s =~ /^-?0d(\d+)$/; # force to a BigInt
    return hex($s) if $s =~ /^0x/i or $opt{hex};
    return $s+0    if $s =~ /^-?\d+$/; # force to a BigInt
    return undef;
}

# -----------------------------------------------------------------
# Return printable representation.
sub number($) {
    my ($n) = @_;
    return $n->as_hex() if $opt{hex};
    return $n;
}

# -----------------------------------------------------------------
sub print_map(+@) {
    my $map = shift @_;
    foreach my $key (@_) {
        print $key, '= ', number($$map{$key}), "\n";
    }
}

# -----------------------------------------------------------------
sub print_bin($) {
    my ($data) = @_;
    for (my $i = 0; $i < length $data; ++$i) {
        printf "%02x", ord substr($data,$i,1);
    }
}

# -----------------------------------------------------------------
sub save_obj(%) {
    my ($old) = @_;
    my %new;
    while (my ($k,$v) = each %$old) {
        $new{$k} = $v;
    }
    $saved = \%new;
}

# -----------------------------------------------------------------
sub read_file($$) {
    my ($file, $size) = @_;
    my $fd;
    if (not open $fd, $file) {
        print "ERROR: cannot open $file: $!\n";
        return undef;
    }
    my $data;
    my $nread = read($fd, $data, $size);
    close $fd;
    if ($nread != $size) {
        print "ERROR: read $nread / $size from $file\n";
        return undef;
    }
    return $data;
}

