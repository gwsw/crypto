#!/usr/bin/perl
use strict;
use bignum;
use Getopt::Long;
use Time::HiRes qw(time);
use Digest::SHA;

Math::BigInt->accuracy(undef);
my $saved;

my $rng_bits_default    = 32;
my $mr_loops_default    = 8;
my $rabin_shift_default = 8;
my $rng; # the active RNG, returned from *_rng_init

my %rngs = (
    'std' => \&std_rng_init, 
    'sec' => \&sec_rng_init, 
    'bbs' => \&bbs_rng_init, 
);

my %opt;

my @opt_hex         = ( 'hex',         'b', "Print numbers in hex." );
my @opt_loops       = ( 'loops',       'i', "Number of loops in Miller-Rabin (default $mr_loops_default)." );
my @opt_orig_rsa    = ( 'orig-rsa',    'b', "Use phi rather than lambda in calculating decryption exponent." );
my @opt_rng         = ( 'rng',         's', "Random number generator (".join(',',keys %rngs)."). Optional bits follows colon (eg. \"bbs:64\")." );
my @opt_seed        = ( 'seed',        's', "Seed string for RNG." );
my @opt_slow_eg     = ( 'slow-eg',     'b', "Don't use Lagrange Theorem shortcut to compute mult. inverse." );
my @opt_rabin_shift = ( 'rabin-shift', 'i', "Bits to use for Rabin disambiguation (default $rabin_shift_default)." );
my @opt_rand_rsa    = ( 'rand-rsa',    'b', "Use random encrytion key rather than 65537." );
my @opt_raw_rabin   = ( 'raw-rabin',   'b', "Don't pad message; decryption prints all 4 candidates." );

my @all_options = (
    \@opt_hex,
    \@opt_loops,
    \@opt_orig_rsa,
    \@opt_rng,
    \@opt_seed,
    \@opt_slow_eg,
    \@opt_rabin_shift,
    \@opt_rand_rsa,
    \@opt_raw_rabin,
);

# -----------------------------------------------------------------
sub uprint {
    my ($cmd, $wcmd, $args) = @_;
    print "  $wcmd $args" if not $cmd or ($wcmd and $cmd eq $wcmd);
}

# -----------------------------------------------------------------
sub usage {
    my ($cmd) = @_;
    if ($cmd eq 'shell') {
        $cmd = '';
        print "usage: crypto [options] [command args...]\n";
        foreach my $option (@all_options) {
            my ($var, $type, $desc) = @$option;
            printf "        --%-13s %s\n", $var . ($type eq 'b' ? ' ' : '='), $desc;
        }
    }
    uprint($cmd, '', "commands: (values in {} may be '-' if preceded by *-gen)\n");
    uprint($cmd, 'euclid', "NUM1 NUM2\n");
    uprint($cmd, 'exp', "BASE EXP MOD\n");
    uprint($cmd, 'find-prime', "BITS\n");
    uprint($cmd, 'gcd', "NUM1 NUM2\n");
    uprint($cmd, 'help', "[command]\n");
    uprint($cmd, 'inv', "NUM MOD\n");
    uprint($cmd, 'is-prime', "NUM\n");
    uprint($cmd, 'kx', "BITS\n");
    uprint($cmd, 'lcm', "NUM1 NUM2\n");
    uprint($cmd, 'luhn', "[-g] CCN\n");
    uprint($cmd, 'random', "MIN MAX\n");
    uprint($cmd, 'random-bytes', "BYTES\n");
    uprint($cmd, 'shuffle', "NUM\n");
    uprint($cmd, 'verhoeff', "[-g] CCN\n");
    uprint($cmd, 'rsa-gen', "BITS\n");
    uprint($cmd, 'rsa-encrypt', "{N E} MSG\n");
    uprint($cmd, 'rsa-decrypt', "{N D} MSG\n");
    uprint($cmd, 'eg-gen', "BITS\n");
    uprint($cmd, 'eg-sign', "   {P G X} MSG\n");
    uprint($cmd, 'eg-verify', " {P G Y} R S MSG\n");
    uprint($cmd, 'eg-encrypt', "{P G Y} MSG\n");
    uprint($cmd, 'eg-decrypt', "{P G X} R S\n");
    uprint($cmd, 'rabin-gen', "BITS\n");
    uprint($cmd, 'rabin-encrypt', "{N} MSG\n");
    uprint($cmd, 'rabin-decrypt', "{P Q N} MSG\n");
    uprint($cmd, 'option', "[+!]OPTION[=VALUE]...\n");
    return 0;
}

# -----------------------------------------------------------------
exit (main() ? 0 : 1);
sub main {
    my @alist = ('hex', 'loops=i', 'rng=s', 'seed=s', 'slow-eg', 'orig-rsa', 'raw-rabin', 'rand-rsa');
    return usage('shell') if not Getopt::Long::GetOptionsFromArray(\@ARGV, \%opt, @alist);
    $opt{loops} = $mr_loops_default if not $opt{loops};
    $opt{rng} = 'std' if not $opt{rng};
    $opt{seed} = time() if not $opt{seed};
    $opt{'rabin-shift'} = $rabin_shift_default if not $opt{'rabin-shift'};
    return usage() if not set_rng($opt{rng}, $opt{seed});

    return command(@ARGV) if @ARGV;
    for (;;) {
        printf "> ";
        my $line = <>;
        $line =~ s/^\s+//;
        $line =~ s/\s$//;
        next if $line eq '';
        next if $line =~ /^#/;
        last if $line eq 'q' or $line eq 'quit' or $line eq 'exit';
        my @args = split /\s+/, $line;
        print "command failed\n" if not command(@args);
    }
    return 1;
}

# -----------------------------------------------------------------
sub set_rng {
    my ($rname, $seed) = @_;
    my $bits = $rng_bits_default;
    if ($rname =~ /^([^:]+) : (\d+)/x) {
        ($rname, $bits) = ($1,$2);
    }
    my $init = $rngs{$rname};
    return undef if not $init;
    my $new_rng = &$init($bits, $seed);
    $rng = $new_rng if $new_rng;
    return $new_rng;
}

# -----------------------------------------------------------------
sub print_option {
    my ($var) = @_;
    my $fnd_option;
    foreach my $option (@all_options) {
        my ($ovar) = @$option;
        if ($ovar eq $var) {
            $fnd_option = $option;
            last;
        }
    }
    return if not $fnd_option;
    my ($var, $type, $desc) = @$fnd_option;
    print "$var = ";
    if ($type eq 'b') {
        print ($opt{$var} ? 'ON' : 'off');
    } else {
        print $opt{$var};
    }
    print "\n";
}

# -----------------------------------------------------------------
sub command {
    my $cmd = shift @_;
    my $start_time = time();
    if (0) {
    } elsif ($cmd eq 'help') {
        my ($cmd) = @_;
        $cmd = 'shell' if not $cmd;
        usage($cmd);
        return 1;
    } elsif ($cmd eq 'option') {
        if (not @_) {
            foreach my $option (@all_options) {
                my ($var) = @$option;
                print_option($var);
            }
        } else {
            foreach my $var (@_) {
                # May be 'name', '!name', '+name', 'name=value'.
                my $set = undef;
                if ($var =~ /([!+]) (.*)/x) {
                    $var = $2;
                    $set = ($1 eq '+') ? 1 : 0;
                }
                if ($var =~ /^ ([^=]+) = (.*)/x) {
                    $var = $1;
                    $set = $2;
                    if ($set =~ /^on$/i) { $set = 1 }
                    if ($set =~ /^off$/i) { $set = 0 }
                }
                # Lookup option in all_options.
                my $type = '';
                foreach my $option (@all_options) {
                    my ($ovar, $otype) = @$option;
                    if ($ovar eq $var) {
                        $type = $otype;
                        last;
                    }
                }
                if (not $type) {
                    print "ERROR: invalid option $var\n";
                    return 1;
                }
                if ($type ne 'b' and not defined $set) {
                    print "ERROR: missing = after option $var\n";
                    return 1;
                }
                my $value = (defined $set) ? $set : not $opt{$var};
                if ($type eq 'i' and $value !~ /^\d+$/ and $value !~ /^0x[0-9a-f]+$/i) {
                    print "ERROR: invalid number $value for option $var\n";
                    return 1;
                }
                if ($var eq 'rng' and not set_rng($value, $opt{seed})) {
                    print "ERROR: cannot set RNG\n";
                    return 1;
                }
                if ($var eq 'seed' and not set_rng($opt{rng}, $value)) {
                    print "ERROR: cannot seed RNG\n";
                    return 1;
                }
                $opt{$var} = $value;
                print_option($var);
            }
        }
    } elsif ($cmd eq 'euclid') {
        my ($u, $v) = args(\@_);
        return usage($cmd) if not defined $v;
        if ($u < $v) { ($u,$v) = ($v,$u); }
        my ($w,$x,$a,$b,$gcd,$k) = euclid($u, $v);
        my $ngcd = number($gcd);
        print $ngcd, ' = ', number($a), ' * ', number($w), ' - ', number($b), ' * ', number($x), "\n";
        print (' ' x length($ngcd));
        print ' = (', number($a), '>>', number($k), ') * ', number($u), ' - (', number($b), '>>', number($k), ') * ', number($v), "\n";
        if ($gcd == 1) {
            print number($x), '^-1 mod ', number($w), ' = ', number($w-$b), "\n";
        }
    } elsif ($cmd eq 'exp') {
        my ($base, $exp, $mod) = args(\@_);
        return usage($cmd) if not $mod;
        my $n = pow_mod($base, $exp, $mod);
        print number($n), "\n";
    } elsif ($cmd eq 'find-prime') {
        my ($bits) = args(\@_);
        return usage($cmd) if not $bits;
        my $n = find_prime($bits);
        print number($n), "\n";
    } elsif ($cmd eq 'find-tough-prime') {
        my ($bits) = args(\@_);
        return usage($cmd) if not $bits;
        my $n = find_tough_prime($bits);
        print number($n), "\n";
    } elsif ($cmd eq 'is-prime') {
        my ($num) = args(\@_);
        return usage($cmd) if not $num;
        print is_prime($num) ? "probably prime\n" : "composite\n";
    } elsif ($cmd eq 'gcd') {
        my ($u, $v) = args(\@_);
        return usage($cmd) if not defined $v;
        my $gcd = gcd($u, $v);
        print number($gcd), "\n";
    } elsif ($cmd eq 'inv') {
        my ($num, $mod) = args(\@_);
        return usage($cmd) if not defined $mod;
        my $inv = inv($num, $mod);
        print number($inv), "\n";
    } elsif ($cmd eq 'lcm') {
        my ($u, $v) = args(\@_);
        return usage($cmd) if not defined $v;
        my $lcm = lcm($u, $v);
        print number($lcm), "\n";
    } elsif ($cmd eq 'random') {
        my ($min, $max) = args(\@_);
        return usage($cmd) if not $max;
        my $n = random($min, $max);
        print number($n), "\n";
    } elsif ($cmd eq 'random-bytes') {
        my ($bytes) = args(\@_);
        return usage($cmd) if not $bytes;
        my $data = $rng->{get}($rng, $bytes);
        if (not $data) {
            print "RNG failed\n";
            return 0;
        } else {
            for (my $i = 0; $i < length $data; ++$i) {
                printf "%02x ", ord substr($data,$i,1);
            }
            print "\n";
        }
    } elsif ($cmd eq 'shuffle') {
        my ($num) = args(\@_);
        return usage($cmd) if not $num;
        my @nums = 1 .. $num;
        shuffle(\@nums);
        print join(' ', @nums), "\n";

    } elsif ($cmd eq 'rsa-gen') {
        my ($bits) = args(\@_);
        return usage($cmd) if not $bits or $bits < 3;
        my $rsa = rsa_gen($bits);
        if ($rsa) {
            save_obj($rsa);
            print_map($rsa, 'e','d','n');
        }
    } elsif ($cmd eq 'rsa-decrypt' or $cmd eq 'rsa-encrypt') {
        my ($n,$e,$msg) = args(\@_, 'n', ($cmd eq 'rsa-decrypt') ? 'd' : 'e');
        return usage($cmd) if not $n or not $e or not defined $msg;
        my $num = rsa_crypt($msg, $e, $n);
        print number($num), "\n";

    } elsif ($cmd eq 'eg-gen') {
        my ($bits) = args(\@_);
        return usage($cmd) if not $bits or $bits < 3;
        my $eg = eg_gen($bits);
        if ($eg) {
            save_obj($eg);
            print_map($eg, 'p','g','y','x');
        }
    } elsif ($cmd eq 'eg-sign') {
        my ($p,$g,$x,$msg) = args(\@_, 'p','g','x');
        return usage($cmd) if not $msg;
        my $sig = eg_sign($p,$g,$x,$msg);
        if ($sig) {
            print number($$sig{r}), ' ', number($$sig{s}), "\n";
        }
    } elsif ($cmd eq 'eg-verify') {
        my ($p,$g,$y,$r,$s,$msg) = args(\@_, 'p','g','y');
        return usage($cmd) if not $s;
        if (not eg_verify($p,$g,$y,$msg,$r,$s)) {
            print "FAIL\n";
            return 0;
        }
        print "ok\n";
    } elsif ($cmd eq 'eg-encrypt') {
        my ($p,$g,$y,$msg) = args(\@_, 'p','g','y');
        return usage($cmd) if not $msg;
        my $enc = eg_encrypt($p,$g,$y,$msg);
        if ($enc) {
            print number($$enc{r}), ' ', number($$enc{s}), "\n";
        }
    } elsif ($cmd eq 'eg-decrypt') {
        my ($p,$g,$x,$r,$s) = args(\@_, 'p','g','x');
        return usage($cmd) if not $s;
        my $msg = eg_decrypt($p,$g,$x,$r,$s);
        if ($msg) {
            print number($msg), "\n";
        }

    } elsif ($cmd eq 'rabin-gen') {
        my ($bits) = args(\@_);
        return usage($cmd) if not $bits;
        $bits += $opt{'rabin-shift'} if not $opt{'raw-rabin'};
        my $rabin = rabin_gen($bits);
        if ($rabin) {
            save_obj($rabin);
            print_map($rabin, 'p','q','n');
        }
    } elsif ($cmd eq 'rabin-encrypt') {
        my ($n,$msg) = args(\@_, 'n');
        return usage($cmd) if not $n or not defined $msg;
        # Use N low order zero bits to distinguish between 4 posssible decryptions.
        $msg = lshift($msg, $opt{'rabin-shift'}) if not $opt{'raw-rabin'};
        my $enc = rabin_encrypt($msg, $n);
        if ($enc) {
            print number($enc), "\n";
        }
    } elsif ($cmd eq 'rabin-decrypt') {
        my ($p,$q,$n,$enc) = args(\@_, 'p','q','n');
        return usage($cmd) if not $p or not $q or not defined $enc;
        # Look for the correct decryption among the 4.
        my $decs = rabin_decrypt($enc, $p, $q, $n);
        if (not $decs) { 
            print "decrypt failed\n";
        } else {
            foreach my $m (@$decs) {
                if ($opt{'raw-rabin'}) { # just print them all.
                    print number($m), "\n";
                } elsif (($m & rmask($opt{'rabin-shift'})) == 0) {
                    # Found one with N low order zero bits.
                    # It might be the right decryption (or we might be very unlucky).
                    print number(rshift($m, $opt{'rabin-shift'})), "\n";
                }
            }
        }

    } elsif ($cmd eq 'kx') {
        my ($bits) = args(\@_);
        return usage($cmd) if not $bits;
        dh_key_exchange($bits);
    } elsif ($cmd eq 'luhn' or $cmd eq 'verhoeff') {
        my ($flag, $ccn) = @_;
        my $gen = ($flag and $flag eq '-g');
        $ccn = $flag if not $gen;
        return usage($cmd) if not defined $ccn;
        my $ch = ($cmd eq 'luhn') ? luhn($ccn, $gen) : verhoeff($ccn, $gen);
        if (not defined $ch) {
            print "INVALID DIGIT\n";
            return 0;
        } elsif ($gen) {
            print "$ccn$ch\n";
        } elsif ($ch == 0) {
            print "ok\n";
        } else {
            print "INVALID CHECK\n";
            return 0;
        }
    } else {
        print "invalid command; \"help\" for help\n";
        return 0;
        return usage();
    }
    printf "=%.6f sec\n", time()-$start_time if $opt{t};
    return 1;
}

# -----------------------------------------------------------------
# ---- El Gamal
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# p,g,y public
# x private
sub eg_gen {
    my ($bits) = @_;
    my $p = find_prime($bits); # shared
    my $g = random(2, $p-1); # shared
    my $x = random(2, $p-1); # private
    my $y = pow_mod($g, $x, $p); # public
    return { 'p' => $p, 'g' => $g, 'x' => $x, 'y' => $y };
}

# -----------------------------------------------------------------
sub eg_sign {
    my ($p,$g,$x,$msg) = @_;
    my $k = eg_k($p);
    my $r = pow_mod($g, $k, $p);
    my $ki = inv($k, $p-1);
    my $s = xmod(($msg - $x * $r) * $ki, $p-1);
    return { 'r' => $r, 's' => $s };
}

# -----------------------------------------------------------------
sub eg_verify {
    my ($p,$g,$y,$msg,$r,$s) = @_;
    my $c1 = mul_mod(pow_mod($y, $r, $p), pow_mod($r, $s, $p), $p);
    my $c2 = pow_mod($g, $msg, $p);
    return ($c1 == $c2);
}

# -----------------------------------------------------------------
sub eg_encrypt {
    my ($p,$g,$y,$msg) = @_;
    my $k = eg_k($p);
    my $r = pow_mod($g, $k, $p);
    my $s = mul_mod(pow_mod($y, $k, $p), $msg, $p);
    return { 'r' => $r, 's' => $s };
} 

# -----------------------------------------------------------------
sub eg_decrypt {
    my ($p,$g,$x,$r,$s) = @_;
    my $h;
    if ($opt{'slow-eg'}) {
        $h = inv(pow_mod($r, $x, $p), $p);
    } else {
        $h = pow_mod($r, $p-$x-1, $p);
    }
    return undef if not defined $h;
    return mul_mod($s, $h, $p);
}

# -----------------------------------------------------------------
sub eg_k {
    my ($p) = @_;
    for (;;) {
        my $k = random(2, $p-2);
        return $k if gcd($k, $p-1) == 1;
    }
}

# -----------------------------------------------------------------
# ---- RSA
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub rsa_gen {
    my ($bits) = @_;
    my $bits2 = rshift($bits, 1); # bits/2 for p, and bits/2 for q
    my $p = find_prime($bits2);
    my $q = find_prime($bits2);
    my $n = $p * $q; # public
    my $n1 = $opt{'orig-rsa'} ? ($p-1) * ($q-1) : lcm($p-1, $q-1);
    my $e = rsa_exponent($bits, $n1); # public
    my $d = inv($e, $n1); # private
    die "keys don't fit in $bits bits; try -e?\n" if $e >= $n or $d >= $n;
    return { 'e' => $e, 'd' => $d, 'n' => $n };
}

# -----------------------------------------------------------------
sub rsa_exponent {
    my ($bits, $n1) = @_;
    my $e = $opt{'rand-rsa'} ? 0 : 65537;
    for (;;) {
        $e = random(2, $n1-1) | 1 if not $e;
        return $e if gcd($e,$n1) == 1;
        $e = 0;
    } 
}

# -----------------------------------------------------------------
sub rsa_crypt {
    my ($msg, $e, $n) = @_;
    return pow_mod($msg, $e, $n);
}

# -----------------------------------------------------------------
# --- Rabin Encryption
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub rabin_gen {
    my ($bits) = @_;
    return undef if not $bits;
    my $bits2 = rshift($bits, 1);
    my $p = find_blum_prime($bits2);
    my $q = find_blum_prime($bits2);
    if ($p < $q) { ($p,$q) = ($q,$p); }
    return { 'p' => $p, 'q' => $q, 'n' => $p*$q };
}

# -----------------------------------------------------------------
sub rabin_encrypt {
    my ($msg, $n) = @_;
    if ($msg >= $n) {
        print "ERROR: plaintext $msg must be less than $n\n";
        return undef;
    }
    return ($msg * $msg) % $n;
}

# -----------------------------------------------------------------
# Returns four possible decryptions.
sub rabin_decrypt {
    my ($enc, $p, $q, $n) = @_;
    if ($enc >= $n) {
        print "ERROR: encryption $enc must be less than $n\n";
        return undef;
    }
    # mp = sqrt(enc) mod p. That is, (mp*mp % p) == enc.
    my $mp = pow_mod($enc, rshift($p+1,2), $p);
    my $mq = pow_mod($enc, rshift($q+1,2), $q);

    my ($xp,$xq,$yp,$yq) = euclid($p, $q);
    die if $xp != $p or $xq != $q;

    # Use Chinese remainder theorem to find 4 candidates r1..r4.
    my $t1 = xmod($yp * $p * $mq, $n);
    my $t2 = xmod($yq * $q * $mp, $n);
    my $r1 = xmod($t1 + $t2, $n);
    my $r2 = xmod($t1 - $t2, $n);
    my $r3 = $n - $r1;
    my $r4 = $n - $r2;

    my @r = ($r1, $r2, $r3, $r4);
    return \@r;
}

# -----------------------------------------------------------------
# ---- Encrypted Key Exchange
# -----------------------------------------------------------------

#
#   Es / Ds = symmetric encrypt / decrypt
#   Ea / Da = asymmetric encrypt / decrypt
#   pwd = shared password
#
#   A generates random Kpub and Kpriv keys
#   A publishes A1 = Es(pwd, Kpub)
#
#   B calculates Kpub' = Ds(pwd, A1)
#   B generates random Kb
#   B publishes B1 = Es(pwd, Ea(Kpub', Kb))
#
#   A calculates Kb' = Da(Kpriv, Ds(pwd, B1))
#   A generates random Ra
#   A publishes A2 = Es(Kb', Ra)
#
#   B calculates Ra' = Ds(Kb, A2)
#   B generates random Rb
#   B publishes B2 = Es(Kb, Ra'.Rb)
#
#   A calculates Rc = Ds(Kb', B2)
#   A verifies substr(Rc,0,len(Ra)) eq Ra
#   A calculates Rb' = substr(Rc,len(Ra))
#   A publishes A3 = Es(Kb', Rb')
#
#   B calculates Rb'' = Ds(Kb, A3)
#   B verifies Rb'' eq Rb
#
#


# -----------------------------------------------------------------
# ---- Math
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Return ($base ** $exp) % $mod, in O(lg($exp)).
sub pow_mod {
    my ($base, $exp, $mod) = @_;
    my $res = 1;
    for (; $exp != 0; $exp = rshift($exp,1)) {
        $res = mul_mod($res, $base, $mod) if ($exp & 1);
        $base = mul_mod($base, $base, $mod);
    }
    return $res;
}

# -----------------------------------------------------------------
sub mul_mod {
    my ($a, $b, $mod) = @_;
    return ($a * $b) % $mod;
}

# -----------------------------------------------------------------
# Miller-Rabin primality test.
sub is_prime {
    my ($num) = @_;
    my $loops = $opt{loops};

    # For efficiency, try some small prime factors first.
    return 0 if $num <= 1;
    return ($num == 2) if is_even($num);
    foreach my $p (qw(3 5 7 11 13 17 19 23 27)) {
        return 1 if $num == $p;
        return 0 if ($num % $p) == 0;
    }

    # Find s,t such that (t * 2**s == num-1), t odd.
    # ie. s is number of trailing zeros in binary representation of num-1,
    # and t is num-1 with those zeros right-shifted away.
    my $s = 0;
    my $t = $num-1;
    while (is_even($t)) {
        ++$s;
        $t = rshift($t,1);
    }

    # Repeat Miller-Rabin loops times, each with a random witness.
    while ($loops-- > 0) {
        my $a = random(2, $num-2); # witness
        my $x = pow_mod($a, $t, $num);
        return 0 if pow_mod($x, $num-1, $num) != 1;
        # Look for fake sqrt of 1: x^2 = 1 but x != +-1.
        for (my $i = 0; $i < $s; ++$i) {
            my $x2 = mul_mod($x, $x, $num);
            return 0 if $x2 == 1 and $x != 1 and $x != $num-1;
            $x = $x2;
        }
    }
    return 1; # probably prime
}

# -----------------------------------------------------------------
# Find a random prime number, a specified number of bits in length.
sub find_prime {
    my ($bits) = @_;
    my $m = lshift(1,$bits);
    my $n = random(rshift($m,1), $m-1) | 1;
    for (;; $n -= 2) { last if is_prime($n); }
    return $n;
}

# -----------------------------------------------------------------
sub find_blum_prime {
    my ($bits) = @_;
    for (;;) {
        my $p = find_prime($bits);
        return $p if ($p % 4) == 3;
    }
}

# -----------------------------------------------------------------
# Find a prime p such that p-1 has at least one large prime factor.
sub find_tough_prime {
    my ($bits) = @_;
    my $bits2 = rshift($bits,1);
    my $m = lshift(1,$bits2)-1;
    for (;;) {
        my $q = find_prime($bits2); # pick the large factor first
        my $r = random(2, $m);
        my $p = ($q*$r)+1;
        return $p if is_prime($p);
    }
}

# -----------------------------------------------------------------
# Extended Euclidean algorithm.
# euclid(u,v) returns (w,x,a,b,g,k) such that
#   w = u>>k, x = v>>k, , u = w<<k, v = x<<k, w,x not both even
#   g = gcd(u,v) = a*w - b*x = (a>>k)*u - (b>>k)*v
sub euclid {
    my ($u, $v) = @_;
    if ($u < $v) { ($u,$v) = ($v,$u); }
    my $k = 0;
    for (; is_even($u) and is_even($v); ++$k) {
        $u = rshift($u,1); $v = rshift($v,1);
    }
    my ($u1, $u2, $u3, $v1, $v2, $v3) = (1, 0, $u, $v, $u-1, $v);
    do {
        do {
            if (is_even($u3)) {
                if (not is_even($u1) or not is_even($u2)) {
                    $u1 += $v; $u2 += $u;
                }
                $u1 = rshift($u1,1); $u2 = rshift($u2,1); $u3 = rshift($u3,1);
            }
            if (is_even($v3) or $u3 < $v3) { # swap u* with v*
                ($u1,$u2,$u3,$v1,$v2,$v3) = ($v1,$v2,$v3,$u1,$u2,$u3);
            }
        } while (is_even($u3));
        while ($u1 < $v1 or $u2 < $v2) {
            $u1 += $v; $u2 += $u;
        }
        $u1 -= $v1; $u2 -= $v2; $u3 -= $v3;
    } while ($v3 > 0); 
    while ($u1 >= $v and $u2 >= $u) {
        $u1 -= $v; $u2 -= $u;
    }
    $u1 = lshift($u1,$k); $u2 = lshift($u2,$k); $u3 = lshift($u3,$k);
    return ($u, $v, $u1, $u2, $u3, $k);
}

# -----------------------------------------------------------------
# Return (u^-1 % v); that is, x such that u*x % v == 1.
sub inv {
    my ($u, $v) = @_;
    my ($u2,$v2,$a,$b,$gcd) = euclid($u, $v);
    return undef if $gcd != 1; # no inverse
    return $u2 - $b;
}

# -----------------------------------------------------------------
# Return greatest common divisor of u and v.
sub gcd {
    my ($u, $v) = @_;
    my ($u2,$v2,$a,$b,$gcd) = euclid($u, $v);
    return $gcd;
}

# -----------------------------------------------------------------
# Return least common multiple of u and v.
sub lcm {
    my ($u, $v) = @_;
    my $gcd = gcd($u, $v);
    return undef if not $gcd;
    return new Math::BigInt(($u * $v) / $gcd); # Makes a BigFloat without this nonsense!
}

# -----------------------------------------------------------------
sub is_even {
    my ($n) = @_;
    return ($n & 1) == 0;
}

# -----------------------------------------------------------------
# Return random integer between $min and $max inclusive.
# Get random bytes and do arithmetic.
sub random {
    my ($min, $max) = @_;
    return $min if $min >= $max;
    my $m = $max - $min + 1;
    my $bytes = 1 + int(log($m) / log(256));
    my $rand = $rng->{get}($rng, $bytes);
    my $n = 0;
    for (my $i = 0; $i < $bytes; ++$i) {
        $n = lshift($n,8) + ord(substr($rand,$i,1));
    }
    # FIXME: mod here is biased.
    $n = ($n % $m);
    return $min + $n;
}

# -----------------------------------------------------------------
# Standard RNG. Uses rand().
sub std_rng_init {
    my ($bits, $seed) = @_;
    if ($seed and length($seed) > 0) {
        srand(int_from_bytes($bits, $seed));
    }
    return { 'get' => \&std_rng_get };
}

sub std_rng_get {
    my ($std, $bytes) = @_;
    my $data = '';
    while (length($data) < $bytes) {
        $data .= chr(int(rand(0x1000000)) >> 8);
    }
    return $data;
}

# -----------------------------------------------------------------
# Secure RNG. Uses Math::Random::Secure.
sub sec_rng_init {
    my ($bits, $seed) = @_;
    if (not eval "require Math::Random::Secure") {
        print "Math::Random::Secure module not found\n";
        return undef;
    }
    if ($seed and length($seed) > 0) {
        Math::Random::Secure::srand($seed);
    }
    return { 'get' => \&sec_rng_get };
}

sub sec_rng_get {
    my ($sec, $bytes) = @_;
    my $data = '';
    while (length($data) < $bytes) {
        $data .= chr(Math::Random::Secure::irand() & 0xff);
    }
    return $data;
}

# -----------------------------------------------------------------
# Blum-Blum-Shub RNG.
sub bbs_rng_init {
    my ($bits, $seed) = @_;
    $seed = 1 if not $seed;
    $rng = std_rng_init($bits, $seed); # bizarre that BBS needs another RNG
    my $rabin = rabin_gen($bits);
    return undef if not $rabin;
    my $rn = $rabin->{n};
    my $x = int_from_bytes($bits, $seed) % $rn;
    while (gcd($x, $rn) != 1) {
        return undef if not $x;
        --$x;
    }
    return { 'get' => \&bbs_rng_get, 'n' => $rn, 'x' => $x };
}

sub bbs_rng_get {
    my ($bbs, $bytes) = @_;
    my $byte = 0;
    my $bytebits = 0;
    my $data = '';
    my $n = $bbs->{n};
    my $x = $bbs->{x};
    while (length($data) < $bytes) {
        $x = ($x * $x) % $n;
        $byte = lshift($byte,1) | ($x & 1);
        if (++$bytebits == 8) {
            $data .= chr $byte;
            $byte = 0;
            $bytebits = 0;
        }
    }
    $bbs->{x} = $x;
    return $data;
}

# -----------------------------------------------------------------
# Diffie-Hellman key exchange
sub dh_key_exchange {
    my ($bits) = @_;
    my $base = 3;
    my $mod = find_prime($bits);
    my $sa = random(rshift($mod,1), $mod-1);
    my $sb = random(rshift($mod,1), $mod-1);
    my $pa = pow_mod($base, $sa, $mod);
    my $pb = pow_mod($base, $sb, $mod);
    my $ab = pow_mod($pb, $sa, $mod);
    my $ba = pow_mod($pa, $sb, $mod);

    print "A and B agree on base $base and modulus $mod\n";
    print "A generates secret $sa\n";
    print "B generates secret $sb\n";
    print "A calculates $base^$sa mod $mod = $pa and publishes it\n";
    print "B calculates $base^$sb mod $mod = $pb and publishes it\n";
    print "A calculates shared $pb^$sa mod $mod = $ab\n";
    print "B calculates shared $pa^$sb mod $mod = $ba\n";
}

# -----------------------------------------------------------------
# Standard credit card check digit.
sub luhn {
    my ($ccn, $gen) = @_;
    my $total = 0;
    $ccn .= '0' if $gen;
    for (my $i = 0; $i < length($ccn); ++$i) {
        my $digit = ord(substr($ccn, length($ccn)-$i-1, 1)) - ord('0');
        return undef if $digit < 0 or $digit >= 10;
        $digit *= 2 if $i & 1;
        $digit -= 9 if $digit > 9;
        $total += $digit;
    }
    $total %= 10;
    $total = 10 - $total if $gen and $total > 0;
    return $total;
}

# -----------------------------------------------------------------
# Better credit card check digit.
sub verhoeff {
    my ($ccn, $gen) = @_;
    my @d = (
        [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
        [ 1, 2, 3, 4, 0, 6, 7, 8, 9, 5 ],
        [ 2, 3, 4, 0, 1, 7, 8, 9, 5, 6 ],
        [ 3, 4, 0, 1, 2, 8, 9, 5, 6, 7 ],
        [ 4, 0, 1, 2, 3, 9, 5, 6, 7, 8 ],
        [ 5, 9, 8, 7, 6, 0, 4, 3, 2, 1 ],
        [ 6, 5, 9, 8, 7, 1, 0, 4, 3, 2 ],
        [ 7, 6, 5, 9, 8, 2, 1, 0, 4, 3 ],
        [ 8, 7, 6, 5, 9, 3, 2, 1, 0, 4 ],
        [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ],
    );
    my @p = (
        [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
        [ 1, 5, 7, 6, 2, 8, 3, 0, 9, 4 ],
        [ 5, 8, 0, 3, 7, 9, 6, 1, 4, 2 ],
        [ 8, 9, 1, 6, 0, 4, 3, 5, 2, 7 ],
        [ 9, 4, 5, 3, 1, 2, 6, 8, 7, 0 ],
        [ 4, 2, 8, 6, 5, 7, 3, 9, 0, 1 ],
        [ 2, 7, 9, 3, 8, 0, 6, 4, 1, 5 ],
        [ 7, 0, 4, 6, 9, 1, 3, 2, 5, 8 ],
    );
    my @inv = ( 0, 4, 3, 2, 1, 5, 6, 7, 8, 9 );

    $ccn .= '0' if $gen;
    my $total = 0;
    for (my $i = 0; $i < length($ccn); ++$i) {
        my $digit = ord(substr($ccn, length($ccn)-$i-1, 1)) - ord('0');
        return undef if $digit < 0 or $digit >= 10;
        my $p = ${$p[$i % 8]}[$digit];
        $total = ${$d[$total]}[$p];
    }
    $total = $inv[$total] if $gen;
    return $total;
}

# -----------------------------------------------------------------
# Fisher-Yates
sub shuffle {
    my ($list) = @_;
    for (my $i = @$list-1; $i > 0; --$i) {
        my $j = random(0,$i);
        ($$list[$i], $$list[$j]) = ($$list[$j], $$list[$i]);
    }
}

# -----------------------------------------------------------------
# ---- Misc
# -----------------------------------------------------------------

# -----------------------------------------------------------------
sub args {
    my $args = shift @_;
    my @rargs;
    foreach my $arg (@$args) {
        if ($arg eq '-') {
            foreach my $var (@_) {
                push @rargs, $$saved{$var};
            }
        ## } elsif ($arg =~ /^-([a-z]+)/) {
        ##     $flags .= $1;
        } else {
            my $val = i($arg);
            return undef if not defined $val;
            push @rargs, $val;
        }
    }
    return @rargs;
}


# -----------------------------------------------------------------
sub int_from_bytes {
    my ($bits, $bytes) = @_;
    my $hash = Digest::SHA::sha256($bytes);
    my $num = 0;
    for (my $i = 0; $i < $bits; ++$i) {
        my $bit = (ord(substr($hash, int($i/8), 1)) >> ($i%8)) & 1;
        $num |= lshift($bit, $i);
    }
    ## $num = -$num if $num < 0;
    return $num;
}

# -----------------------------------------------------------------
sub i {
    my ($s) = @_;
    return hex($s) if $s =~ /^0x/i;
    return $s+0 if $s =~ /^\d+$/; # force to a BigInt
    return undef;
}

# -----------------------------------------------------------------
sub number {
    my ($n) = @_;
    return $n->as_hex() if $opt{x};
    return $n;
}

# -----------------------------------------------------------------
sub print_map {
    my $map = shift @_;
    foreach my $key (@_) {
        print $key, '= ', number($$map{$key}), "\n";
    }
}

# -----------------------------------------------------------------
sub lshift {
    my ($n, $shift) = @_;
    return int($n << $shift);
}

# -----------------------------------------------------------------
sub rshift {
    my ($n, $shift) = @_;
    return int($n >> $shift);
}

# -----------------------------------------------------------------
sub rmask {
    my ($n) = @_;
    return (lshift(1, $n) - 1);
}

# -----------------------------------------------------------------
# Make sure mod does the right thing with negative numbers.
sub xmod {
    my ($n, $m) = @_;
    return $n % $m if $n >= 0;
    my $a = (int(-$n/$m)+2) * $m;
    return ($n + $a) % $m;
}

# -----------------------------------------------------------------
sub print_bin {
    my ($data) = @_;
    for (my $i = 0; $i < length $data; ++$i) {
        my $ch = substr($data, $i, 1);
        printf " %02x", ord $ch;
    }
}

# -----------------------------------------------------------------
sub save_obj {
    my ($old) = @_;
    my %new;
    while (my ($k,$v) = each %$old) {
        $new{$k} = $v;
    }
    $saved = \%new;
}
